<p>Architecture<br />
NSURLConnection<br />
	◦	AFURLConnectionOperation<br />
	◦	AFHTTPRequestOperation<br />
	◦	AFHTTPRequestOperationManager<br />
NSURLSession (iOS 7 / Mac OS X 10.9)<br />
	◦	AFURLSessionManager<br />
	◦	AFHTTPSessionManager<br />
Serialization<br />
	◦	<afurlrequestserialization>
	▪	AFHTTPRequestSerializer
	▪	AFJSONRequestSerializer
	▪	AFPropertyListRequestSerializer
	◦	<afurlresponseserialization>
	▪	AFHTTPResponseSerializer
	▪	AFJSONResponseSerializer
	▪	AFXMLParserResponseSerializer
	▪	AFXMLDocumentResponseSerializer (Mac OS X)
	▪	AFPropertyListResponseSerializer
	▪	AFImageResponseSerializer
	▪	AFCompoundResponseSerializer
Additional Functionality
	◦	AFSecurityPolicy
	◦	AFNetworkReachabilityManager
Usage
HTTP Request Operation Manager
AFHTTPRequestOperationManager encapsulates the common patterns of communicating with a web application over HTTP, including request creation, response serialization, network reachability monitoring, and security, as well as request operation management.
GET Request
AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
[manager GET:@"http://example.com/resources.json" parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
POST URL-Form-Encoded Request
AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
NSDictionary *parameters = @{@"foo": @"bar"};
[manager POST:@"http://example.com/resources.json" parameters:parameters success:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@"JSON: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];
POST Multi-Part Request
AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];
NSDictionary *parameters = @{@"foo": @"bar"};
NSURL *filePath = [NSURL fileURLWithPath:@"file://path/to/image.png"];
[manager POST:@"http://example.com/resources.json" parameters:parameters constructingBodyWithBlock:^(id<afmultipartformdata> formData) {
    [formData appendPartWithFileURL:filePath name:@"image" error:nil];
} success:^(AFHTTPRequestOperation *operation, id responseObject) {
    NSLog(@"Success: %@", responseObject);
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {
    NSLog(@"Error: %@", error);
}];</afmultipartformdata></afurlresponseserialization></afurlrequestserialization></p>

<p>AFURLSessionManager<br />
AFURLSessionManager creates and manages an NSURLSession object based on a specified NSURLSessionConfiguration object, which conforms to <nsurlsessiontaskdelegate>, <nsurlsessiondatadelegate>, <nsurlsessiondownloaddelegate>, and <nsurlsessiondelegate>.
Creating a Download Task
NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</nsurlsessiondelegate></nsurlsessiondownloaddelegate></nsurlsessiondatadelegate></nsurlsessiontaskdelegate></p>

<p>NSURL *URL = [NSURL URLWithString:@”http://example.com/download.zip”];<br />
NSURLRequest *request = [NSURLRequest requestWithURL:URL];</p>

<p>NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:nil destination:^NSURL *(NSURL *targetPath, NSURLResponse *response) {<br />
    NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil];<br />
    return [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];<br />
} completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error) {<br />
    NSLog(@”File downloaded to: %@”, filePath);<br />
}];<br />
[downloadTask resume];<br />
Creating an Upload Task<br />
NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];<br />
AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</p>

<p>NSURL *URL = [NSURL URLWithString:@”http://example.com/upload”];<br />
NSURLRequest *request = [NSURLRequest requestWithURL:URL];</p>

<p>NSURL *filePath = [NSURL fileURLWithPath:@”file://path/to/image.png”];<br />
NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithRequest:request fromFile:filePath progress:nil completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {<br />
    if (error) {<br />
        NSLog(@”Error: %@”, error);<br />
    } else {<br />
        NSLog(@”Success: %@ %@”, response, responseObject);<br />
    }<br />
}];<br />
[uploadTask resume];<br />
Creating an Upload Task for a Multi-Part Request, with Progress<br />
NSMutableURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@”POST” URLString:@”http://example.com/upload” parameters:nil constructingBodyWithBlock:^(id<afmultipartformdata> formData) {
        [formData appendPartWithFileURL:[NSURL fileURLWithPath:@"file://path/to/image.jpg"] name:@"file" fileName:@"filename.jpg" mimeType:@"image/jpeg" error:nil];
    } error:nil];</afmultipartformdata></p>

<p>AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];<br />
NSProgress *progress = nil;</p>

<p>NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithStreamedRequest:request progress:&amp;progress completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {<br />
    if (error) {<br />
        NSLog(@”Error: %@”, error);<br />
    } else {<br />
        NSLog(@”%@ %@”, response, responseObject);<br />
    }<br />
}];</p>

<p>[uploadTask resume];<br />
Creating a Data Task<br />
NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];<br />
AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</p>

<p>NSURL *URL = [NSURL URLWithString:@”http://example.com/upload”];<br />
NSURLRequest *request = [NSURLRequest requestWithURL:URL];</p>

<p>NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) {<br />
    if (error) {<br />
        NSLog(@”Error: %@”, error);<br />
    } else {<br />
        NSLog(@”%@ %@”, response, responseObject);<br />
    }<br />
}];<br />
[dataTask resume];</p>

<p>Request Serialization<br />
Request serializers create requests from URL strings, encoding parameters as either a query string or HTTP body.<br />
NSString *URLString = @”http://example.com”;<br />
NSDictionary *parameters = @{@”foo”: @”bar”, @”baz”: @[@1, @2, @3]};<br />
Query String Parameter Encoding<br />
[[AFHTTPRequestSerializer serializer] requestWithMethod:@”GET” URLString:URLString parameters:parameters error:nil];<br />
GET http://example.com?foo=bar&amp;baz[]=1&amp;baz[]=2&amp;baz[]=3<br />
URL Form Parameter Encoding<br />
[[AFHTTPRequestSerializer serializer] requestWithMethod:@”POST” URLString:URLString parameters:parameters];<br />
POST http://example.com/<br />
Content-Type: application/x-www-form-urlencoded</p>

<p>foo=bar&amp;baz[]=1&amp;baz[]=2&amp;baz[]=3<br />
JSON Parameter Encoding<br />
[[AFJSONRequestSerializer serializer] requestWithMethod:@”POST” URLString:URLString parameters:parameters];<br />
POST http://example.com/<br />
Content-Type: application/json</p>

<p>{“foo”: “bar”, “baz”: [1,2,3]}</p>

<p>Network Reachability Manager<br />
AFNetworkReachabilityManager monitors the reachability of domains, and addresses for both WWAN and WiFi network interfaces.<br />
	◦	Do not use Reachability to determine if the original request should be sent.<br />
	▪	You should try to send it.<br />
	◦	You can use Reachability to determine when a request should be automatically retried.<br />
	▪	Although it may still fail, a Reachability notification that the connectivity is available is a good time to retry something.<br />
	◦	Network reachability is a useful tool for determining why a request might have failed.<br />
	▪	After a network request has failed, telling the user they’re offline is better than giving them a more technical but accurate error, such as “request timed out.”<br />
See also WWDC 2012 session 706, “Networking Best Practices.”.<br />
Shared Network Reachability<br />
[[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {<br />
    NSLog(@”Reachability: %@”, AFStringFromNetworkReachabilityStatus(status));<br />
}];</p>

<p>[[AFNetworkReachabilityManager sharedManager] startMonitoring];<br />
HTTP Manager Reachability<br />
NSURL *baseURL = [NSURL URLWithString:@”http://example.com/”];<br />
AFHTTPRequestOperationManager *manager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:baseURL];</p>

<p>NSOperationQueue *operationQueue = manager.operationQueue;<br />
[manager.reachabilityManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {<br />
    switch (status) {<br />
        case AFNetworkReachabilityStatusReachableViaWWAN:<br />
        case AFNetworkReachabilityStatusReachableViaWiFi:<br />
            [operationQueue setSuspended:NO];<br />
            break;<br />
        case AFNetworkReachabilityStatusNotReachable:<br />
        default:<br />
            [operationQueue setSuspended:YES];<br />
            break;<br />
    }<br />
}];</p>

<p>[manager.reachabilityManager startMonitoring];</p>

<p>Security Policy<br />
AFSecurityPolicy evaluates server trust against pinned X.509 certificates and public keys over secure connections.<br />
Adding pinned SSL certificates to your app helps prevent man-in-the-middle attacks and other vulnerabilities. Applications dealing with sensitive customer data or financial information are strongly encouraged to route all communication over an HTTPS connection with SSL pinning configured and enabled.<br />
Allowing Invalid SSL Certificates<br />
AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];<br />
manager.securityPolicy.allowInvalidCertificates = YES; // not recommended for production</p>

<p>AFHTTPRequestOperation<br />
AFHTTPRequestOperation is a subclass of AFURLConnectionOperation for requests using the HTTP or HTTPS protocols. It encapsulates the concept of acceptable status codes and content types, which determine the success or failure of a request.<br />
Although AFHTTPRequestOperationManager is usually the best way to go about making requests, AFHTTPRequestOperation can be used by itself.<br />
GET with AFHTTPRequestOperation<br />
NSURL *URL = [NSURL URLWithString:@”http://example.com/resources/123.json”];<br />
NSURLRequest *request = [NSURLRequest requestWithURL:URL];<br />
AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc] initWithRequest:request];<br />
op.responseSerializer = [AFJSONResponseSerializer serializer];<br />
[op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {<br />
    NSLog(@”JSON: %@”, responseObject);<br />
} failure:^(AFHTTPRequestOperation *operation, NSError *error) {<br />
    NSLog(@”Error: %@”, error);<br />
}];<br />
[[NSOperationQueue mainQueue] addOperation:op];<br />
Batch of Operations<br />
NSMutableArray *mutableOperations = [NSMutableArray array];<br />
for (NSURL *fileURL in filesToUpload) {<br />
    NSURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@”POST” URLString:@”http://example.com/upload” parameters:nil constructingBodyWithBlock:^(id<afmultipartformdata> formData) {
        [formData appendPartWithFileURL:fileURL name:@"images[]" error:nil];
    }];</afmultipartformdata></p>

<pre><code>AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];

[mutableOperations addObject:operation]; }
</code></pre>

<p>NSArray *operations = [AFURLConnectionOperation batchOfRequestOperations:@[…] progressBlock:^(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations) {<br />
    NSLog(@”%lu of %lu complete”, numberOfFinishedOperations, totalNumberOfOperations);<br />
} completionBlock:^(NSArray *operations) {<br />
    NSLog(@”All operations in batch complete”);<br />
}];<br />
[[NSOperationQueue mainQueue] addOperations:operations waitUntilFinished:NO];<br />
Unit Tests<br />
AFNetworking includes a suite of unit tests within the Tests subdirectory. In order to run the unit tests, you must install the testing dependencies via CocoaPods:<br />
$ cd Tests<br />
$ pod install<br />
Once testing dependencies are installed, you can execute the test suite via the ‘iOS Tests’ and ‘OS X Tests’ schemes within Xcode.<br />
Running Tests from the Command Line<br />
Tests can also be run from the command line or within a continuous integration environment. The xcpretty utility needs to be installed before running the tests from the command line:<br />
$ gem install xcpretty<br />
Once xcpretty is installed, you can execute the suite via rake test.</p>

<p>//install<br />
platform :ios, ‘8.0’</p>

<p>pod ‘AFNetworking’, ‘~&gt; 3.0’</p>

