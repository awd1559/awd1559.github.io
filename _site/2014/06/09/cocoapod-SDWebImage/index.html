<p>Using UIImageView+WebCache category with UITableView<br />
Just #import the UIImageView+WebCache.h header, and call the sd_setImageWithURL:placeholderImage: method from the tableView:cellForRowAtIndexPath: UITableViewDataSource method. Everything will be handled for you, from async downloads to caching management.<br />
#import &lt;SDWebImage/UIImageView+WebCache.h&gt;</p>

<p>…</p>

<ul>
  <li>
    <p>(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath<br />
{<br />
  static NSString *MyIdentifier = @”MyIdentifier”;</p>

    <p>UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier];</p>

    <p>if (cell == nil)<br />
  {<br />
      cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault<br />
                                     reuseIdentifier:MyIdentifier] autorelease];<br />
  }</p>

    <p>// Here we use the new provided sd_setImageWithURL: method to load the web image<br />
  [cell.imageView sd_setImageWithURL:[NSURL URLWithString:@”http://www.domain.com/path/to/image.jpg”]<br />
                    placeholderImage:[UIImage imageNamed:@”placeholder.png”]];</p>

    <p>cell.textLabel.text = @”My Text”;<br />
  return cell;<br />
}</p>
  </li>
</ul>

<p>Using blocks<br />
With blocks, you can be notified about the image download progress and whenever the image retrieval has completed with success or not:<br />
// Here we use the new provided sd_setImageWithURL: method to load the web image<br />
[cell.imageView sd_setImageWithURL:[NSURL URLWithString:@”http://www.domain.com/path/to/image.jpg”]<br />
                      placeholderImage:[UIImage imageNamed:@”placeholder.png”]<br />
                             completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) {… completion code here …}];<br />
Note: neither your success nor failure block will be call if your image request is canceled before completion.</p>

<p>Using SDWebImageManager<br />
The SDWebImageManager is the class behind the UIImageView+WebCache category. It ties the asynchronous downloader with the image cache store. You can use this class directly to benefit from web image downloading with caching in another context than a UIView (ie: with Cocoa).<br />
Here is a simple example of how to use SDWebImageManager:<br />
SDWebImageManager *manager = [SDWebImageManager sharedManager];<br />
[manager downloadImageWithURL:imageURL<br />
                      options:0<br />
                     progress:^(NSInteger receivedSize, NSInteger expectedSize) {<br />
                         // progression tracking code<br />
                     }<br />
                     completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) {<br />
                         if (image) {<br />
                             // do something with image<br />
                         }<br />
                     }];</p>

<p>Using Asynchronous Image Downloader Independently<br />
It’s also possible to use the async image downloader independently:<br />
[SDWebImageDownloader.sharedDownloader downloadImageWithURL:imageURL<br />
                                                    options:0<br />
                                                   progress:^(NSInteger receivedSize, NSInteger expectedSize)<br />
                                                   {<br />
                                                       // progression tracking code<br />
                                                   }<br />
                                                   completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished)<br />
                                                   {<br />
                                                       if (image &amp;&amp; finished)<br />
                                                       {<br />
                                                           // do something with image<br />
                                                       }<br />
                                                   }];</p>

<p>Using Asynchronous Image Caching Independently<br />
It is also possible to use the async based image cache store independently. SDImageCache maintains a memory cache and an optional disk cache. Disk cache write operations are performed asynchronous so it doesn’t add unnecessary latency to the UI.<br />
The SDImageCache class provides a singleton instance for convenience but you can create your own instance if you want to create separated cache namespace.<br />
To lookup the cache, you use the queryDiskCacheForKey:done: method. If the method returns nil, it means the cache doesn’t currently own the image. You are thus responsible for generating and caching it. The cache key is an application unique identifier for the image to cache. It is generally the absolute URL of the image.<br />
SDImageCache *imageCache = [[SDImageCache alloc] initWithNamespace:@”myNamespace”];<br />
[imageCache queryDiskCacheForKey:myCacheKey done:^(UIImage *image)<br />
{<br />
    // image is not nil if image was found<br />
}];<br />
By default SDImageCache will lookup the disk cache if an image can’t be found in the memory cache. You can prevent this from happening by calling the alternative method imageFromMemoryCacheForKey:.<br />
To store an image into the cache, you use the storeImage:forKey: method:<br />
[[SDImageCache sharedImageCache] storeImage:myImage forKey:myCacheKey];<br />
By default, the image will be stored in memory cache as well as on disk cache (asynchronously). If you want only the memory cache, use the alternative method storeImage:forKey:toDisk: with a negative third argument.</p>

<p>Using cache key filter<br />
Sometime, you may not want to use the image URL as cache key because part of the URL is dynamic (i.e.: for access control purpose). SDWebImageManager provides a way to set a cache key filter that takes the NSURL as input, and output a cache key NSString.<br />
The following example sets a filter in the application delegate that will remove any query-string from the URL before to use it as a cache key:<br />
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions<br />
{<br />
    SDWebImageManager.sharedManager.cacheKeyFilter = ^(NSURL *url) {<br />
        url = [[NSURL alloc] initWithScheme:url.scheme host:url.host path:url.path];<br />
        return [url absoluteString];<br />
    };</p>

<pre><code>// Your app init code...
return YES; }
</code></pre>

