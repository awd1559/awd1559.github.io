<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AWD</title>
    <description>Motion、Music、Code，SiFi | 这里是 @awd1559的个人日志。</description>
    <link>http://emotion.net.cn/</link>
    <atom:link href="http://emotion.net.cn/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 23 Mar 2016 15:10:21 +0800</pubDate>
    <lastBuildDate>Wed, 23 Mar 2016 15:10:21 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>xcode</title>
        <description>&lt;pre&gt;&lt;code&gt;1.	#pragma mark — 的“-”后面不能有空格, 技巧：连写两个-。
2.	如果你的标志没有出现在弹出菜单中，比如没有分隔线出现，请在Xcode菜单 “Preferences..”中的 “Code Sense”选项取消选中”Sort list alphabetically”即可。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;XXX-Info.plist		工程描述文件&lt;br /&gt;
InfoPlist.strings		本地化字符串&lt;br /&gt;
mani.m				入口文件&lt;br /&gt;
XXX-Prefix.pch		引入头文件&lt;/p&gt;

&lt;p&gt;文件夹是灰色的，组是黄色的&lt;br /&gt;
文件夹中路径需要指明，组中资源不用指出路径&lt;/p&gt;

&lt;p&gt;Scene通过Segue跳转&lt;br /&gt;
跳转的类型分：Push、Modal、Popover和自定义&lt;/p&gt;

&lt;p&gt;反向调用&lt;br /&gt;
NSString *className = @“MyViewController”;&lt;br /&gt;
Class viewControllerKlass = NSClassFromString(viewControllerClassName);&lt;br /&gt;
NSAssert(viewControllerKlass, @”Class should not be nil!”);&lt;br /&gt;
NSAssert([viewControllerKlass isSubclassOfClass:[UIViewController class]], @”Class should be a view controller!”);&lt;br /&gt;
UIViewController *demoViewController = [[viewControllerKlass alloc] initWithNibName:nil bundle:nil];&lt;/p&gt;

&lt;p&gt;快捷键:&lt;br /&gt;
Open Quickly 			        ctrl+shift+o	打开项目文件&lt;br /&gt;
Standard Editor&amp;gt;Show Document Items  cmd+p          文件中函数跳转&lt;br /&gt;
Reveal in Project Navigator                 cmd+shift+j  在Project中显示文件&lt;br /&gt;
&lt;em&gt;.m&lt;/em&gt;.h切换 ⌘+⌃ +↓or↑&lt;br /&gt;
option + 右键 查看符号的文档&lt;/p&gt;

&lt;p&gt;cmd + .  暂停模拟器&lt;/p&gt;

&lt;p&gt;CMD+[     左缩进&lt;br /&gt;
CMD+]     右缩进&lt;/p&gt;

&lt;p&gt;前进后退文本文件⌘+⌃ +←or→&lt;br /&gt;
自动排版代码 ⌃+i&lt;br /&gt;
左右缩进 ⌘+[or]&lt;br /&gt;
注释 ⌘+/&lt;br /&gt;
查看名称定义，进入头文件 ⌘+鼠标左键&lt;br /&gt;
查看名称api文档 ⌥+鼠标左键&lt;/p&gt;

&lt;p&gt;doc位置&lt;br /&gt;
/Application/Xcode.app/Contents/Developer/Documentation/DocSets&lt;br /&gt;
app临时编译位置&lt;br /&gt;
/Users/awd/Library/Developer/Xcode/DerivedData预览sb、xib：&lt;br /&gt;
左上角preview&lt;/p&gt;

&lt;p&gt;shift+Option(alt) : 设置预览&lt;br /&gt;
ctrl + Option : 预览&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Jan 2015 20:00:00 +0800</pubDate>
        <link>http://emotion.net.cn/2015/01/29/xcode/</link>
        <guid isPermaLink="true">http://emotion.net.cn/2015/01/29/xcode/</guid>
        
        <category>apple</category>
        
        <category>xcode</category>
        
        
      </item>
    
      <item>
        <title>temp</title>
        <description>&lt;p&gt;UISwitch&lt;br /&gt;
//selector函数不存在，只报错，编译能通过&lt;br /&gt;
[[UISwitch alloc] initWithFrame:CGRectZero]&lt;br /&gt;
[switch setOn:YES]&lt;br /&gt;
[switch addTarget:self action:@selector(switchIsChanged:)	&lt;br /&gt;
	forControlEvents:UIControlEventValueChanged];&lt;br /&gt;
-(void)switchIsChanged:(UISwitch*)switch{}&lt;/p&gt;

&lt;p&gt;switch.tintColor		off state color&lt;br /&gt;
switch.onTintColor		on state color&lt;br /&gt;
switch.thumbTintColor	knob color &lt;/p&gt;

&lt;p&gt;&amp;lt;UIPickerViewDataSource, UIPickerViewDelegate&amp;gt;&lt;br /&gt;
UIPickerView *picker = [[UIPickerView alloc] init];&lt;br /&gt;
picker.dataSource = self;&lt;br /&gt;
picker.delegate = self;&lt;/p&gt;

&lt;p&gt;#pragma UIPickerViewDataSource&lt;br /&gt;
-(NSInteger) numberOfComponentsInPickerView:(UIPickerView*)picker;&lt;br /&gt;
-(NSInteger)pickerView:numberOfRowsInComponent:&lt;/p&gt;

&lt;uipickerviewdelegate&gt;
-(NSString*)pickerView:titleForRow:forComponent:

UIDatePicker* picker = [[UIDatePicker alloc] init];
picker.datePickerMode = UIDatePickerModeDate;
NSDate *date = picker.date;

NSTimeInterval oneYearTime = 365 * 24 * 60 * 60;
NSDate *today = [NSDate date];
NSDate *oneYearLater = [today dateByAddingTimeInterval:oneYearTime];
NSDate *twoYearLater = [today dateByAddingTimeInterval:2*oneYearTime];
picker.minimumDate = oneYearLater;
picker.maximumDate = twoYearLater;

picker.datePickerMode = UIDatePickerModeCountDownTimer;
NSTimeInterval twoMinutes = 2 * 60;
[picker setCountDownDuration:twoMinutes];


UISlider *slider = [[UISlider alloc] initWithFrame:CGRectMake(0, 0, 200, 23);
slider.minimumValue = 0.0f;
slider.maximumValue = 100.0f;

[slider setMinimumValueImage]
[slider setMinimumTrackImage:forState];
[slider setThumbImage:forState:UIControlStateNormal];
[slider setThumbImage:forState:UIControlStateHighlighted];
[slider setMaximumTrackImage:forState];
[slider setMaximumValueImage];

slider.minimumTrackTintColor
slider.maximumTrackTintColor
slider.thumbTintColor


NSArray *segs;
UISegmentedControl *segment = [[UISegmentedControl alloc] initWithItems:segs];
segment.segmentedControlStyle = UISegmentedControlStyleBezeled;


//UIActivityViewController
UIActivityViewController *activity = 
[[UIActivityViewController alloc] initWithActivityItems:@[] applicationActivities:customActivity];
//弹出Share ViewController
[self presentViewController:activity animated:YES completion:^{};];

customActivity : UIActivity&lt;uiactivitydelegate&gt;{
	-(NSString*)activityType
	-(NSString*)activityTitle	
	-(UIImage*) activityImage	显示定制图片
}


//UINavigationController
UINavigationController nav = [[UINavigationController alloc] initWithRootViewController:viewController];

secondViewController *second = [secondViewController alloc] initWith
[nav pushViewController:second animated:YES];

-(void)goBack{
	[nav popViewControllerAnimated:YES];
}
[self performSelector:@selector(goBack) withObject:nil afterDelay:5.0f];

NSArray *currentControllers = self.navigationController.viewControllers;
MSMutableArray *newControllers = [NSMutableArray arrayWithArray:currentControllers];
[newControllers removeLastObject];
self.navigationController.viewControllers = newControllers;

self.navigatonItem.titleView = imageView;


//tab


//UITextField右侧显示¥符号
UILabel *left = [[UILabel alloc] initWithFrame:CGRectZero];
left.text = [[[NSNumberFormatter alloc] init] currencySymbo]; //$符号
textField.leftView = left;
textField.leftViewMode = UITextFieldViewModeAlways;



//UITextView多行显示


//UIButton
UIImage *normalImage = [UIImage imageNamed:@“NormalButton”];
UIImage *highlightedImage = [UIImage imageNamed:@“HighlightedButton”];
UIButton *button [UIButton buttonWithType:UIButtonTypeCustom];
[button setBackgroundImage:normalImage forState:];
[button setTitle:@“Normal” forState:UIControlStateNormal];
[button setBackgroundImage:highlightedImage forState;]
[button setTitle:@“Pressed” forState:UIControlStateHighlighted];

//UIImageView
UIImage *image = [UIImage imageNamed:@“”];
imageView.contentMode = UIViewContentModeScaleAspectFit;

//UIScrollView
UIScrollView scroll = [[UIScrollView alloc] initWithFrame:CGRectMake];
scroll.pagingEnabled = YES;
scroll.contentSize = CGSizeMake();
[scroll addSubView:];


//UIProgressView
UIProgressView progress = [[UIPorgressView alloc] initWithProgressViewStyle:UIProgressViewStyleBar];
progress.progress = 20.0f / 30.0f;



//animator
UIDynamicAnimator animator = [[UIDynamicAnimatior alloc] initWithReferenceView:self.view];
UIGravityBehavior *gravity = [[UIGravityBehavior alloc] initWithItems:@[myview]];			//赋予myviewgravity
[animator addBehavior:gravity];




//autolayout
button.translatesAutoresizingMaskIntoConstraints = NO;


NSLayoutConstraint *centerXCons = 
[NSLayoutConstraint constraintWithItem:button
                      attribute:NSLayoutAttributeCenterX
                      relatedBy:NSLayoutRelatioinEqual
                         toItem:button.superview
                      attribute:NSLayoutAttributeCenterX
                     multiplier:1.0f
                       constant:0.0f];
[self.view addConstraint:centerXCons];


//Visual Format Language
H:[button]-[textField]		标准间距
H:[button]—8-[textField]	水平间距8
H:[button(&amp;gt;=50)]		button.width &amp;gt;=50
H:|-50-[box]-50-|		距左边50，右边50；
V:[topField]-10-[buttonField]	垂直间距10

[maroonView][oceanView]		Flush Views
[button(100@20)]		Priority
[button1(==button2)]		Equal Widths
[flexButton(&amp;gt;=70, &amp;lt;=100)]

NSDictionary *views = NSDictionaryOfVariableBindings(v1, v2, v3);
NSArray *con = [NSLayoutConstraint constraintsWithVisualFormat:@“H||” optons:metrics:nil views:views];

[self.view addConstraints:cons];


//fonts
for(NSString*familyName in [UIFont familyNames])
	for(NSString *fontName in [UIFont fontNamesForFamilyName:familyName]

UIFont *font = [UIFont fontWithName:@“Thonburi-Bold” size:12.0f];
UIFont *font = [UIFont boldSystemFontOfSize:30];

[myString drawAtPoint:CGPointMake(40, 180) withAttributes:@{
	NSFontAttributeName : font}];

[mystring drawWithRect:CGRectMake(100, 120, 100, 200) options:attributes:@{NSFontAttributeName: font} context:nil];

UIImage *image = [UIImage imageNamed:@“xcode”];
[image drawAtPoint:CGPointMake(0.0f, 20.0f)];
[image drawInRect:CGRectMake(50.0f, 10.0f, 40.0f, 35.0f)];

UIEdgeInsets edges;
edges.left = 14.0f;
edges.top  = 0.0f;
edges.right = 14.0f;
edges.bottom = 0.0f;
UIImage *image =[UIImage imageNamed:@“Button”];
[image resizeableImageWithCapInsets:edges];

-(void)drawRect:(CGRect)rect{
	CGContextRef context = UIGraphicsGetCurrentContext();

	CGContextSetLineJoin(context, kCGLineJoinRound);
	CGContextSetShadowWithColor(context, CGSizeMake(10.0f, 10.0f), 20.0f, [[UIColor grayColor] CGColor]);
	CGContextSetLineWidth(context, 5.0f);

	CGContextMoveToPoint(context, 50.0f, 10.0f);

	CGContextAddLineToPoint(context, 100.0f, 200.0f);

	CGContextStrokePath(context);
}


//UITableView
UITableView *table = [[UITableView alloc] initWithFrame:self.view.bounds style:UITableViewStylePlain];
[table registerClass:[UITableViewCell class] forCellReuseIdentifier:TTT];
table.delegate = self;
table.dataSource = self;
table.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;


#pragam UITableViewDataSource
-(NSInteger) numberOfSectionsInTableView
-(NSInteger) table:numberOfRowsInSection:

-(UITableViewCell)tableView:cellForRowAtIndexPath
	UITableViewCell* cell = nil;
	cell = [tableView dequeueReusableCellWithIdentifier:TTT forIndexPath:;
	cell.textLabel.text
	result.accessoryType = UITableViewCellAccessoryDetailDisclosureButton;
	cell.accessoryView = myview;

-(NSString*)tableView:titleForHeaderInSection:
-(NSString*)tableView:titleForFooterInSection:


//for UIViewController editButtonItem
-(void)setEditing:animated:
	table setEditing:animated:
tableView:editintStyleForRowAtIndexPath:
	return UITableViewCellEditingStyleDelete;
tableView:commitEditingStyle:forRowAtIndexPath:
	if(editingStyle == UITableViewCellEditingStyleDelete)
	table deleteRowsAtIndexPaths:withRowAnimation:UITableViewRowAnimationLeft
	//and remove model data;
tableView:canEditRowAtIndexPath:
tableView:canMoveRowAtIndexPath:
tableView:moveRowAtIndexPath:toIndexPath:


#pragam UITableViewDelegate
//row高度
-(CGFloat) tableView:heightForRowAtIndexPath:

//header高度
-(CGFloat) tableView:heightForHeaderInSection:
-(UIView*) tableView:viewForHeaderInSection:

//footer高度
-(CGFloat) tableView:heightForFooterInSection:
-(UIView*) tableView:viewForFooterInSection:

//context menu
-(BOOL) tableView:shouldShowMenuForRowAtIndexPath:
//show copy menu
-(BOOL) tableView:canPerformAction
	if(action == @selector(copy:)return YES;
-(void) tableViw:performAction:forRowAtIndexPath:withSender
	if(action == @selector(copy:))
	UITableViewCell *cell = [table cellForRowAtIndexPath:];
	UIPasteboard *board = [UIPasteBoard generalPasteboard];
	[board setString:cell.textlabel.text];


//move
//move data first
[table moveSection:0 toSection:2]
[table moveRowAtIndexPath:source toIndexPath:dest];


UICollectionViewFlowLaout *layout = [[UICollectionViewFlowLayout alloc] init];
layout.minimumLineSpaceing = 20.0f;
layout.minimumInteritemSpacing = 20.0f;
layout.itemSize = CGSizeMake(80.0f, 120.0f);
layout.scrollDirection = UICollectionViewScrollDirectionVertical;
layout.sectionInset = UIEdgeInsetMake(10.0f, 20.0f, 10.0f, 20.0f);

ViewContrller* collection =  [[ViewController alloc] initWithCollectionViewLayout:layout];


ViewController : UICollectionView
-(instancetype) initWithCollectionViewLayout:
    self = [super initWithCollectionViewLayout:layout];
    if (self != nil){
        /* Register the cell with the collection view for easy retrieval */
        [self.collectionView registerClass:[UICollectionViewCell class]
                forCellWithReuseIdentifier:kCollectionViewCellIdentifier];

        /* or reusable nib file */
        UINib *nib = [UINib nibWithNibName:
                      NSStringFromClass([MyCollectionViewCell class])
                                    bundle:[NSBundle mainBundle]];
        [self.collectionView registerNib:nib
              forCellWithReuseIdentifier:kCollectionViewCellIdentifier];
    }
    return self;

-(NSInteger) collectionView:numberOfItemsInSection:
-(UICollectionViewCell*) collectionView:cellForItemAtIndexPath:
    UICollectionViewCell *cell = [collectionView dequeueReuseableCellWithReuseIdentifier:kCollectionViewCellIdentifier forIndexPath:indexPath];

//highlight时触发
- (void) collectionView:didHighlightItemAtIndexPath:
    UICollectionViewCell *selectedCell =
        [collectionView cellForItemAtIndexPath:indexPath];
    
    [UIView animateWithDuration:0.2f animations:^{
        selectedCell.transform = CGAffineTransformMakeScale(2.0f, 2.0f);
    }];

-(void) collectionView:didUnhighlightItemAtIndexPath:

-(void) collectionView:didSelectItemAtIndexPath:


//context menu
- (BOOL)collectionView:shouldShowMenuForItemAtIndexPath:
- (BOOL)collectionView:canPerformAction:forItemAtIndexPath:withSender
- (BOOL)collectionView:performActio:forItemAtIndexPath:withSender

//gesture
- (void) handlePinches:(UIPinchGestureRecognizer *)
    CGSize DefaultLayoutItemSize = CGSizeMake(80.0f, 120.0f);
    
    UICollectionViewFlowLayout *layout =
        (UICollectionViewFlowLayout *)self.collectionView.collectionViewLayout;
    
    layout.itemSize =
    CGSizeMake(DefaultLayoutItemSize.width * paramSender.scale,
               DefaultLayoutItemSize.height * paramSender.scale);
    
    [layout invalidateLayout];



//core data
.xcdatamodeld
//new
Person *newPerson = [NSEntityDescription
                         insertNewObjectForEntityForName:@&quot;Person&quot;
                         inManagedObjectContext:self.managedObjectContext];
NSError *savingError = nil;
[self.managedObjectContext save:&amp;amp;savingError]

//fetch
NSFetchRequest *fetchRequest = [[NSFetchRequest alloc]
                                    initWithEntityName:@&quot;Person&quot;];

//sort
NSSortDescriptor *ageSort = [[NSSortDescriptor alloc] initWithKey:@&quot;age&quot; ascending:YES];
NSSortDescriptor *firstNameSort = [[NSSortDescriptor alloc] initWithKey:@&quot;firstName&quot; ascending:YES];
fetchRequest.sortDescriptors = @[ageSorg, firstNameSort];

NSArray *persons =
    [self.managedObjectContext executeFetchRequest:fetchRequest
                                             error:&amp;amp;requestError];
if([persons count] &amp;gt; 0)
    for(Person *p in persons)



//delete
Person *p = [persons lastObject];
self.managedObjectContext deleteObject:p;
if([p isDeleted])


//binding
    &lt;nsfetchedresultscontrollerdelegate&gt;
NSFetchedResultsController *frc =
    [[NSFetchedResultsController alloc]
     initWithFetchRequest:fetchRequest
     managedObjectContext:[self managedObjectContext]
     sectionNameKeyPath:nil
     cacheName:nil];
frc.delegate = self;

#pargram UITableViewDelegate
    id &lt;nsfetchedresultssectioninfo&gt; sectionInfo =
        self.frc.sections[section];
    return sectionInfo.numberOfObjects;                //获取的数据数目


    Person *person = [frc objectAtIndexPath:indexPath];//获取一项数据


#pargram NSFetchedResultsControllerDelegate
-(void) controllerWillChangeContent:
-(void) controllerDidChangeContent:
-(void) controller:didChangeObject:atIndexPath:
     forChangeType:(NSFetchedRewaultsChangeType)type
      newIndexPath:


//relationship in models

//background fetch
NSManagedObjectContext *backgroundContext =
    [[NSManagedObjectContext alloc]
     initWithConcurrencyType:NSPrivateQueueConcurrencyType];
backgroundContext.persistentStoreCoorinator = self.persistentStoreCoordinator;
backgroundContext performBlock:^{
    NSError *error = nil;
    NSArray *personIds = [backgroundContext executeFetchRequest:[]]

    dispatch_async(dispatch_get_main_queue(). ^{});
}




//File I/O
NSFileManager *fileManager = [[NSFileManager alloc] init];
NSArray *urls = [fileManager URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask];
    NSDocumentDirectory
    NSCachesDirectory
    NSTemporaryDirectory

NSString *filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;MyFile.txt&quot;];
char bytes[4] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;};
NSData *dataFromBytes = [[NSData alloc] initWithBytes:bytes
                                                   length:sizeof(bytes)];
if([dataFromBytes writeToFile:filePath atomically:YES])
    NSData *readData = [[NSData alloc] initWithContentsOfFile:filePath];




//network
NSString *urlAsString = @&quot;http://www.apple.com&quot;;
NSURL *url = [NSURL URLWithString:urlAsString];
NSURLRequest *urlRequest = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalAndRemoteCacheData timeoutInterval:30.0f];
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
NSURLConnection sendAsynchronousRequest:urlRequest:queue:completionHandler:];

NSError *error = nil;
NSURLResponse *response = nil;
NSData *data = [NSURLConnection sendSynchronousRequest:urlRequest returningResponse:&amp;amp;response erro:&amp;amp;error];


dispatch_queue_t dispatchQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_async(dispatchQueue, ^(void){});





















//LocationManager
CLLocationManager *locationManager = [[CLLocationManager alloc] init];
[locationmanager setDistanceFilter:kCLDistanceFilterNone];
[locationManager setDesiredAccuracy:kCLLocationAccuracyBest];
[locationManager startUpdatingLocation];

#CLLocationManagerDelegate
- (void)locatioinManager:didUpdateToLocation:fromLocation
- (void)locationManager:didFailWithErro

-(void)locationManager:didUpdateHeading:

NSNotificationCenter *nc = [NSNotificationCenter defaultCenter];
[nc addObserver:self selector:@selector(:) name:object:nil];
当任意对象发布name消息时，self执行selector

[[NSNotificatinCenter defaultCenter] removeObserver:self]













//gcd
dispatch_async(dispatch_get_global_queue())
dispatch_async(dispatch_get_main_queue())
dispatch_once(dispatch_once_t )
dispatch_after(dispatch_time_t );
dispatch_group_async(dispatch_group_t )
dispatch_group_notify(dispatch_group_t )字符串格式化：
NSString *title = [sender titleForState:UIControlStateNormal];
    NSString *plainText = [NSString stringWithFormat:@&quot;%@ button pressed.&quot;, title];
    NSMutableAttributedString *styledText = [[NSMutableAttributedString alloc]
                                             initWithString:plainText];
    NSDictionary *attributes =
    @{
      NSFontAttributeName : [UIFont boldSystemFontOfSize:_statusLabel.font.pointSize]
      };
    
    NSRange nameRange = [plainText rangeOfString:title];
    
    [styledText setAttributes:attributes range:nameRange];
    _statusLabel.attributedText = styledText;



tableview
使用tag获取storyboard中的view
UITableView *tableView = (id)[self.view viewWithTag:1];
还是使用IBoutlet




cell初始化
UITableViewCell *cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@“Cell”];



UITableViewCell *cell
cell.textLabel.text = [NSString ];
cell.detailTextLaabel.text 
cell.imageViwe.image = [UIImage imageNamed:];
cell.imageView.highlightedImage








覆盖 UITableViewDelegate,   每个cell的向右偏移
-(NSInteger)tableView:(UITableViw*)tableView  indentationLevelForRowAtIndexPath:(NSIndexPath*) indexPath
{
	return ;
}





scrollView中contentView滚动的弹性区域
top = 20,使得tableView不和status bar 区域重叠
UIEdgeInsets contentInset = tableView.contentInset;
contentInset.top = 20;
[tableView setContentInset:contentInset];








//加入search
UISearchBar *searchBar = [[UISearchBar alloc]
                              initWithFrame:CGRectMake(0, 0, 320, 44)];
tableView.tableHeaderView = searchBar;
UISearchDisplayController *searchController = [[UISearchDisplayController alloc]
                        initWithSearchBar:searchBar
                        contentsController:self];
searchController.delegate = self;					//UISearchDisplayDelegate
searchController.searchResultsDataSource = self;



//搜索
#pragma mark Search Display Delegate Methods         //iOS8 使用UISearchControllerDelegate
- (void)searchDisplayController:(UISearchDisplayController *)controller
  didLoadSearchResultsTableView:(UITableView *)tableView
{
    [tableView registerClass:[UITableViewCell class]
      forCellReuseIdentifier:SectionsTableIdentifier];
}


- (BOOL)searchDisplayController:(UISearchDisplayController *)controller
shouldReloadTableForSearchString:(NSString *)searchString
{
    [filteredNames removeAllObjects];
    if (searchString.length &amp;gt; 0) {
        NSPredicate *predicate =
        [NSPredicate
         predicateWithBlock:^BOOL(NSString *name, NSDictionary *b) {
             NSRange range = [name rangeOfString:searchString
                                         options:NSCaseInsensitiveSearch];
             return range.location != NSNotFound;
         }];
        for (NSString *key in self.keys) {
            NSArray *matches = [self.names[key]
                                filteredArrayUsingPredicate: predicate];
            [filteredNames addObjectsFromArray:matches];
        }
    }
    return YES;
}


//搜索结果展示
- (NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView              //UITableView右侧的index 显示
{
    if (tableView.tag == 1) {
        return self.keys;
    } else {
        return nil;
    }
}

(NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section
{
    if (tableView.tag == 1) {
        return self.keys[section];
    } else {
        return nil;
    }
}
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
	UITableViewCell *cell = [tableView dequ];
	if(tableView.tag == 1){
		cell.textLabel.text = 
	} else {
		cell.textLabel.text = filteredString[indexPath.row]
	}
	return cell;
}
//UITableView 右侧section index显示
tableView.sectionIndexBackgroundColor = 
tableView.sectionIndexTrackingBackgroundColor
tableView.sectionIndexColor

UserDefault
取出
NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
        NSArray *storedFavorites = [defaults objectForKey:@&quot;favorites&quot;];
        if (storedFavorites) {
            self.favorites = [storedFavorites mutableCopy];
        } else {
            self.favorites = [NSMutableArray array];
        }


保存
NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
[defaults setObject:self.favorites forKey:@&quot;favorites&quot;];
[defaults synchronize];
















&lt;/nsfetchedresultssectioninfo&gt;&lt;/nsfetchedresultscontrollerdelegate&gt;&lt;/uiactivitydelegate&gt;&lt;/uipickerviewdelegate&gt;
</description>
        <pubDate>Thu, 29 Jan 2015 20:00:00 +0800</pubDate>
        <link>http://emotion.net.cn/2015/01/29/temp/</link>
        <guid isPermaLink="true">http://emotion.net.cn/2015/01/29/temp/</guid>
        
        <category>apple</category>
        
        
      </item>
    
      <item>
        <title>rpm</title>
        <description>&lt;p&gt;finger @kernl.org			获得最新的代码列表&lt;/p&gt;

&lt;p&gt;Redhat Package Manager &lt;br /&gt;
rpm -e –nodeps 			强制卸载&lt;br /&gt;
rpm -i src.rpm  			安装软件源代码包&lt;br /&gt;
rpmbuild -bb H.src			做rpm&lt;br /&gt;
rpm -ivh					安装rpm&lt;br /&gt;
rpm -Uivh					升级&lt;/p&gt;

&lt;p&gt;apt-get update&lt;br /&gt;
apt-get install &lt;br /&gt;
apt-get remove&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Jan 2015 20:00:00 +0800</pubDate>
        <link>http://emotion.net.cn/2015/01/29/rpm/</link>
        <guid isPermaLink="true">http://emotion.net.cn/2015/01/29/rpm/</guid>
        
        <category>linux</category>
        
        <category>shell</category>
        
        
      </item>
    
      <item>
        <title>分辨率</title>
        <description>&lt;p&gt;http://iosdesign.ivomynttinen.com/&lt;/p&gt;

&lt;p&gt;The iOS Design Guidelines&lt;/p&gt;

&lt;p&gt;Design great-looking apps for Apple iOS devices.&lt;br /&gt;
Designing iOS apps can be difficult sometimes, but finding correct and up-to-date information about all of Apples’ devices shouldn’t be. These design guidelines will help any designer who’s building neat things for iOS get started within seconds.&lt;/p&gt;

&lt;p&gt;700 Icons for iOS and Android Design only $15&lt;br /&gt;
ADVERTISEMENT&lt;br /&gt;
About these guidelines&lt;/p&gt;

&lt;p&gt;These guidelines describe how to design apps that follow the official HIG for iOS by Apple, not what you can do with custom controls. Sometimes it makes sense to break the rules. The purpose of this document is to guide you, not to provide solutions for complex and unique design problems.&lt;/p&gt;

&lt;p&gt;This unofficial documentation will be updated and extended regularly. Last update: September 28, 2015.&lt;/p&gt;

&lt;p&gt;Resolutions and Display Specifications&lt;/p&gt;

&lt;p&gt;Device	Retina	Portrait (px)	Landscape (px)&lt;br /&gt;
iPhone 6+&lt;br /&gt;
6+, 6S+&lt;br /&gt;
Retina HD	1080 x 1920	1920 x1080&lt;br /&gt;
iPhone 6&lt;br /&gt;
6, 6S&lt;br /&gt;
Retina	750 x 1334	1334 x 750&lt;br /&gt;
iPhone 5&lt;br /&gt;
5, 5S, 5C&lt;br /&gt;
Retina	640 x 1136	1136 x 640&lt;br /&gt;
iPhone 4&lt;br /&gt;
4, 4S&lt;br /&gt;
Retina	640 x 960	960 x 640&lt;br /&gt;
iPhone&lt;br /&gt;
1st, 2nd &amp;amp; 3rd Generation&lt;br /&gt;
No	320 x 480	480 x 320&lt;br /&gt;
iPad Air / Retina iPad&lt;br /&gt;
1st &amp;amp; 2nd Generation / 3rd &amp;amp; 4th&lt;br /&gt;
No	1536 x 2048	2048 x 1536&lt;br /&gt;
iPad Pro	No	2048 x 2732	2732 x 2048&lt;br /&gt;
iPad Mini&lt;br /&gt;
2nd &amp;amp; 3rd Generation&lt;br /&gt;
Retina	1536 x 2048	2048 x 1536&lt;br /&gt;
iPad&lt;br /&gt;
Mini, 1st &amp;amp; 2nd Generation&lt;br /&gt;
No	768 x 1024	1024 x 768&lt;br /&gt;
Difference between Points and Pixels&lt;/p&gt;

&lt;p&gt;Pixels are the smallest physical element that we can control on a digital display. The more pixels can be fitted into a specific screen size, the higher the PPI (pixels-per-inch), and the clearer the rendered content becomes.&lt;/p&gt;

&lt;p&gt;Points are a resolution-independent measurement. Depending on the screens pixel density, a point can contain multiple pixels (e.g., 1 pt contains 2 x 2 pixels on a regular retina display).&lt;/p&gt;

&lt;p&gt;When you are designing for various display types, you should think in points, but design in pixels. This means you will still need to export all your assets in 3 different resolutions, no matter in which resolution you are designing your app.&lt;/p&gt;

&lt;p&gt;NOTE&lt;/p&gt;

&lt;p&gt;As long as it is not stated otherwise (by appending „px“ to a value), this guide always refers to points when it comes to specific dimensions. If you need the value in pixels, just multiply by 2 for Retina screens or by 3 for Retina HD screens.&lt;/p&gt;

&lt;p&gt;Device	Asset Resolution	PPI	Display Size&lt;br /&gt;
iPhone 6+&lt;br /&gt;
6+, 6S+&lt;br /&gt;
@3x	401	5.5″&lt;br /&gt;
iPhone 6&lt;br /&gt;
6, 6S&lt;br /&gt;
@2x	326	4.7″&lt;br /&gt;
iPhone 5&lt;br /&gt;
5, 5S, 5C&lt;br /&gt;
@2x	326	4.0″&lt;br /&gt;
iPhone 4&lt;br /&gt;
4, 4S&lt;br /&gt;
@2x	326	3.5″&lt;br /&gt;
iPhone&lt;br /&gt;
1st, 2nd &amp;amp; 3rd Generation&lt;br /&gt;
@1x	163	3.5″&lt;br /&gt;
iPad Pro	@2x	264	12.9″&lt;br /&gt;
iPad Air / Retina iPad&lt;br /&gt;
1st &amp;amp; 2nd Generation/ 3rd &amp;amp; 4th&lt;br /&gt;
@2x	264	9.7″&lt;br /&gt;
iPad Mini&lt;br /&gt;
2nd &amp;amp; 3rd Generation&lt;br /&gt;
@2x	326	7.9″&lt;br /&gt;
iPad Mini&lt;br /&gt;
1st Generation&lt;br /&gt;
@1x	163	7.9″&lt;br /&gt;
iPad&lt;br /&gt;
1st &amp;amp; 2nd Generation&lt;br /&gt;
@1x	132	9.7″&lt;br /&gt;
Downsampling on iPhone 6+&lt;/p&gt;

&lt;p&gt;Rendered pixels and physical pixels are equal on all iOS devices, with one exception: the Retina HD screen of the iPhone 6 Plus. Because its screen has a lower pixel resolution than what would be a natural @3x resolution, the rendered content is automatically resized to approximately 87% of the original size (from 2208 x 1242 pixels to fit the display resolution of 1920 x 1080 pixels).&lt;/p&gt;

&lt;p&gt;Difference between iPhone 5S 6 6+ displays&lt;br /&gt;
The difference between displays of iPhone 5S, 6 and 6+. More in-depth information here.&lt;br /&gt;
App Icons&lt;/p&gt;

&lt;p&gt;Device	App Icon	AppStore Icon	Spotlight	Settings&lt;br /&gt;
iPhone 6+&lt;br /&gt;
6+, 6S+&lt;br /&gt;
180x180 px	1024x1024 px	120x120 px	87x87 px&lt;br /&gt;
iPhone&lt;br /&gt;
6S, 6, 5S, 5, 5C, 4S, 4&lt;br /&gt;
120x120 px	1024x1024 px	80x80 px	58x58 px&lt;br /&gt;
Old iPhones&lt;br /&gt;
1st, 2nd, 3rd Generation&lt;br /&gt;
57x57 px	1024x1024 px	29x29 px	29x29 px&lt;br /&gt;
iPad Pro	167x167 px	1024x1024 px	120x120 px	58x58 px&lt;br /&gt;
Retina iPads&lt;br /&gt;
Mini 2 &amp;amp; 3, Air, 3 &amp;amp; 4&lt;br /&gt;
152x152 px	1024x1024 px	80x80 px	58x58 px&lt;br /&gt;
Old iPads&lt;br /&gt;
1, 2, Mini 1&lt;br /&gt;
76x76 px	1024x1024 px	40x40 px	29x29 px&lt;br /&gt;
Automatically applied effects&lt;/p&gt;

&lt;p&gt;App icons assets are generally added to the application package as plain, squared PNG files in various dimensions. When rendered on a device, iOS applies various effects to app icons.&lt;/p&gt;

&lt;p&gt;ROUNDED CORNERS&lt;/p&gt;

&lt;p&gt;The old simple radii values for rounded corners are gone. Since iOS 7, app icons have been using the shape of a superellipse. Since Apple did not release an official template of the shape, you will have to use one of the unofficial templates out there that replicate the shape in more or less accurate ways.&lt;/p&gt;

&lt;p&gt;iOS 8 app icon radius shape&lt;br /&gt;
The rounded corners should not be included in the final exported assets, but you might need them in your design process if you want to add effects, such as a stroke or shadows, that are aligned to the corner of the icon.&lt;/p&gt;

&lt;p&gt;WARNING&lt;/p&gt;

&lt;p&gt;If you are masking your icon asset with the superellipse shape because you want to apply effects aligned to the corners, make sure not to use any transparency for the area outside the mask. Transparency is not supported at all for app icons and instead is rendered as plain black. If your mask is not 100% accurate, users will see small black fragments on the rounded edges. It’s recommend to set the background of the canvas to be the same as the app icon background.&lt;/p&gt;

&lt;p&gt;BORDER STROKE (IN SOME SITUATIONS)&lt;/p&gt;

&lt;p&gt;If the app icon you are using has a white background, a 1 pixel gray border stroke will be applied to make it easier to recognize the edges of the icon. This is only done in the settings app (if your application is listed there) and the AppStore.&lt;/p&gt;

&lt;p&gt;LEGACY EFFECTS (IOS 6 AND PREVIOUS VERSIONS)&lt;/p&gt;

&lt;p&gt;On older iOS versions, these effects are applied automatically: rounded corners (not the same shape as iOS 7+ icons are using), drop shadows on the home screen and a gloss effect that can be disabled.&lt;/p&gt;

&lt;p&gt;Grid system&lt;/p&gt;

&lt;p&gt;iOS 8 app icon grid system&lt;br /&gt;
Apple developed a golden ratio grid system that can be used to size and align elements on your icon correctly. Nevertheless, even Apple designers are not following the grid system very strictly with the native apps’ icons. Feel free to break the rules if your icon simply works better without aligning all elements strictly to the grid.&lt;/p&gt;

&lt;p&gt;Typography&lt;/p&gt;

&lt;p&gt;The default system font on all iOS versions previous iOS 9 is Helvetica Neue. With the release of iOS 9, Apple introduced a brand new font called San Francisco, which replaced Helvetica Neue as the default font. San Francisco comes in two shapes: „SF UI Display“ and „SF UI Text“, while „Display“ is primarly used for UI components, „Text“ features a wider letter spacing and should be used for longer texts. You can download the San Francisco fonts here if you are a member of Apple’s Developer program. In addition to the default font, many alternative font faces are available to use. You can find a complete list of pre-installed typefaces here.&lt;/p&gt;

&lt;p&gt;Font Sizes&lt;/p&gt;

&lt;p&gt;Element	Size (pt)	Weight	Spacing (pt)	Type&lt;br /&gt;
Nav Bar Title	17	Medium	0.5	Display&lt;br /&gt;
Nav Bar Button	17	Regular	0.5	Display&lt;br /&gt;
Search Bar	13.5	Regular	0	Text&lt;br /&gt;
Tab Bar Button	10	Regular	0.1	Text&lt;br /&gt;
Table Header	12.5	Regular	0.25	Text&lt;br /&gt;
Table Row	16.5	Regular	0	Text&lt;br /&gt;
Table Row Subline	12	Regular	0	Text&lt;br /&gt;
Table Footer	12.5	Regular	0.2	Text&lt;br /&gt;
Action Sheets	20	Regular / Medium	0.5	Display&lt;br /&gt;
Custom Fonts&lt;/p&gt;

&lt;p&gt;Technically, any True Type Font (.ttf) can be used within an iOS app, but be careful about licenses. It should be safe to use fonts that are completely free for commercial usage. App licenses for commercial fonts are rarely available, and if they are, securing them can turn out to be somewhat expensive. MyFonts currently offers the biggest collection of fonts that can be licensed for mobile app usage.&lt;/p&gt;

&lt;p&gt;Color Palette&lt;/p&gt;

&lt;p&gt;iOS 8 default colors&lt;br /&gt;
Since iOS 7, Apple has been using a vibrant color palette for the interface of the OS and pre-installed apps. While you can use the default iOS color palette listed above, you can also (and probably should, if you want to stand out) use your own colors.&lt;/p&gt;

&lt;p&gt;Iconography&lt;/p&gt;

&lt;p&gt;In iOS apps, icons have always been a great way to support text labels with a visual relationship to the performed action or to replace text completely (often for very common actions such as „New“, „Delete“, etc.). Usually, we are dealing with icons that are part of the Navigation Bar, Tool Bar or Tab Bar.&lt;/p&gt;

&lt;p&gt;Bar Button Icons&lt;/p&gt;

&lt;p&gt;Icons used in bars should always have two different states: the default state in outlined style with a stroke width of 1 or 1.5pt and the active state with a solid color fill.&lt;/p&gt;

&lt;p&gt;iOS button bar outline and solid icons&lt;br /&gt;
You should never include any additional effects such as a drop-shadow or inner shadows on button icons because these are relicts from previous iOS versions (before the iOS 7 redesign). Button icons should be drawn in one solid color on a transparent background—the shape of the icon is used as a mask, and the color will be applied programmatically.&lt;/p&gt;

&lt;p&gt;Activity View Icons&lt;/p&gt;

&lt;p&gt;Icons in the Activity View (also known as Share Popover) used to be designed in outline style, but since iOS 8, Apple has reverted back to solid fill icons on a plain white background.&lt;/p&gt;

&lt;p&gt;iOS activity sheet icons&lt;br /&gt;
Commonly used design elements&lt;/p&gt;

&lt;p&gt;iOS offers a great collection of ready-to-use views and controls that allow app developers to quickly build interfaces. Some elements can be customized to a certain level, but other cannot and probably also should not be. When designing an application for iOS, you should know your set of tools and stick to them whenever possible. However, in some cases, it might be worthwhile to build a custom control because you need a more custom look or want to change the functionality of an already existing control (danger zone). Almost anything is possible,and sometimes it makes sense to break the rules, but always think twice before doing so.&lt;/p&gt;

&lt;p&gt;Status Bar&lt;/p&gt;

&lt;p&gt;The Status Bar contains basic system information such as the current carrier, time, battery status and more. It’s visually connected to the Navigation Bar and makes use of the same background fill. To match the style of your app and guarantee readability, the content of the status bar comes in two different styles: dark (black) and light (white).&lt;/p&gt;

&lt;p&gt;iOS Status Bar &lt;br /&gt;
It is possible to hide the Status Bar, but think twice before doing so. For example, users might be interested in knowing if they are connected to a WiFi network when the app regularly downloads web content or if Bluetooth is enabled when the app requires a Bluetooth link to third-party hardware. A valid reason to hide the Status Bar is when you want to remove all distractions from a single element, for example, when displaying full screen content such as an image gallery.&lt;/p&gt;

&lt;p&gt;Navigation Bar&lt;/p&gt;

&lt;p&gt;The navigation bar contains the controls for navigating through the applications views and optionally to manage the content of the current view. It will always appear at the top of the screen, right below the status bar. By default, the background is slightly translucent and blurs content underneath the bar. The background fill of the bar can be set to a solid color, a gradient or a custom bitmap-pattern.&lt;/p&gt;

&lt;p&gt;iOS Navigation Bar &lt;br /&gt;
Navigation Bar on iPhone 6 in portrait mode.&lt;br /&gt;
iOS Navigation Bar Landscape &lt;br /&gt;
Navigation Bar on iPhone 4S in landscape mode. The height of the bar is reduced by 12pt, except on iPads. It’s also a common practice to hide the status bar in landscape mode.&lt;br /&gt;
The elements should always following a specific alignment pattern.&lt;/p&gt;

&lt;p&gt;Back button should always be aligned to the left side.&lt;br /&gt;
Title of the current view should always be centered in the bar.&lt;br /&gt;
Action buttons should always be aligned to the right side. If possible, there should never be more than one primary action to avoid missed clicks and to maintain simplicity.&lt;br /&gt;
Toolbar&lt;/p&gt;

&lt;p&gt;A toolbar contains a set of actions for managing or manipulating the content of the current view. On the iPhone, it will always appear aligned at the bottom edge of the screen, while on the iPad, it can also be displayed aligned at the top of the screen.&lt;/p&gt;

&lt;p&gt;Similarly to the navigation bar, the background fill of toolbars can be modified, is translucent and blurs the underlaying content by default.&lt;/p&gt;

&lt;p&gt;iOS Toolbar &lt;br /&gt;
Toolbars should be used when a specific view requires more than three primary actions that would hardly fit or would look messy in the navigation bar.&lt;/p&gt;

&lt;p&gt;Search Bar&lt;/p&gt;

&lt;p&gt;Search bars come in two different styles by default: prominent and minimal. Both versions do have the same functionality.&lt;/p&gt;

&lt;p&gt;As long as no text was entered by the user, a placeholder text is shown inside the bar, and, optionally, a bookmarks icon that can be used to access recent or saved searches.&lt;br /&gt;
Once a search term is entered, the placeholder disappears, and a clear button to delete the entered value appears on the right edge.&lt;br /&gt;
Search bars can make use of a prompt — a short sentence to introduce the functionality in the context of the search. For example, „Enter a city, zip code or airport.“&lt;/p&gt;

&lt;p&gt;iOS prominent search bar &lt;br /&gt;
Prominent search bar style, without and with a prompt.&lt;br /&gt;
iOS minimal search bar &lt;br /&gt;
Minimal search bar style.&lt;br /&gt;
To provide even more control over a search query, it is possible to chain the search Bar with a scope bar. The scope bar will use the same style as the search bar and might be useful when there are clearly defined categories for the search results. For example, in a music app, the search results could be filtered again by interpreters, albums or songs.&lt;/p&gt;

&lt;p&gt;Tab Bar&lt;/p&gt;

&lt;p&gt;The tab bar is used to allow the user to quickly navigate through the separate views of an application, and it should only be used for this purpose. It always appears at the bottom edge of the screen. By default, its slightly translucent and uses the same system blur for underlaying content as the navigation bar.&lt;/p&gt;

&lt;p&gt;iOS Tab Bar &lt;br /&gt;
A tab bar can only contain a fixed maximum number of tabs. Once there are more tabs than the maximum count, the last tab displayed will be replaced by a „More-tab“ that will lead to a list of hidden tabs, with an option to re-order the displayed tabs.&lt;/p&gt;

&lt;p&gt;While the maximum amount of tabs displayed is five on iPhones, it’s possible to display up to seven tabs on the iPad while avoiding a more-tab.&lt;/p&gt;

&lt;p&gt;To notify users about new information on a view, it sometimes makes sense to apply a badge count to a tab bar button. If a view is temporarily disabled, the related tab button should not be completely hidden; instead, it should be faded out to visually communicate the disabled state.&lt;/p&gt;

&lt;p&gt;Table View&lt;/p&gt;

&lt;p&gt;Table views are used to display small to large amounts of list style information in a single or multiple columns and with the option to divide several rows into separate sections or to group them.&lt;/p&gt;

&lt;p&gt;There are two basic table view types that should be used, depending on the type of data you are presenting.&lt;/p&gt;

&lt;p&gt;PLAIN&lt;/p&gt;

&lt;p&gt;iOS plain table view &lt;br /&gt;
A plain table contains a number of rows that can have a header on the top and a footer after the last row. It’s possible to display a vertical navigation on the right edge of the screen to navigate through the table, which makes sense when presenting a big data set that could be sorted in some way (e.g., alphabetically descending).&lt;/p&gt;

&lt;p&gt;GROUPED&lt;/p&gt;

&lt;p&gt;iOS grouped table view&lt;br /&gt;
A grouped table allows you to organize rows in groups. Each group can have a header (best used to describe the context for the group) as well as a footer (good for help text, etc.). A grouped table needs to contain at least one group, and each group needs to contain at least one row.&lt;/p&gt;

&lt;p&gt;For both table view types, a few styles are available to present the data in a way that allows users to easily scan, read and probably modify it.&lt;/p&gt;

&lt;p&gt;DEFAULT&lt;/p&gt;

&lt;p&gt;iOS default table view &lt;br /&gt;
A table row in default style has an optional image aligned on the left and a title.&lt;/p&gt;

&lt;p&gt;WITH SUBTITLE&lt;/p&gt;

&lt;p&gt;iOS subtitle table view&lt;br /&gt;
The subtitle table style enables a small subtitle text underneath the row title. It is useful for further explanations or short descriptions.&lt;/p&gt;

&lt;p&gt;WITH VALUE&lt;/p&gt;

&lt;p&gt;iOS subtitle table view&lt;br /&gt;
The value table style allows you to display a specific value that is related to the row title. Similar to the default style, each row can have an image and a title that are both aligned to the left. The title is followed by the right aligned label for the value, which is usually displayed in a slightly more subtle text color than the title.&lt;/p&gt;

&lt;p&gt;Modals, Popovers and Alerts&lt;/p&gt;

&lt;p&gt;iOS provides various styles of temporary views that can be used to display, edit and manipulate data in a way that fits best in a given situation. While each temporary view exists for a very specific purpose and each one looks different, all temporary views still have one thing in common: When displayed, it’s the highest index layer on the current view (they appear on top of everything else), and content underneath is overlayed by a translucent black background.&lt;/p&gt;

&lt;p&gt;ACTIVITY VIEW&lt;/p&gt;

&lt;p&gt;An activity view is used to perform specific tasks. These tasks can be default system tasks such as share content via the available options, or they can be completely custom actions. When designing icons for custom task buttons, you should follow the same guidelines as for the active state of bar button icons — solid fill, no effects, on a transparent background.&lt;/p&gt;

&lt;p&gt;iOS activity sheet view&lt;br /&gt;
ACTIONS&lt;/p&gt;

&lt;p&gt;Action Sheets are used to perform one single action from a list of available actions and to force the user of an app to confirm an action or cancel it.&lt;/p&gt;

&lt;p&gt;iOS action sheet view &lt;br /&gt;
In portrait mode (and on small landscape screen resolutions), actions are always displayed as a list of buttons sliding in and staying at the bottom edge of the screen. In this case, an action sheet should always have a cancel button to close the view and not perform any of the listed actions.&lt;/p&gt;

&lt;p&gt;When there is enough space available (e.g., on iPad screens), action sheets visually transform into popovers. A button to close the view is not required anymore because tapping a target anywhere outside the popover will close it automatically.&lt;/p&gt;

&lt;p&gt;ALERTS&lt;/p&gt;

&lt;p&gt;The purpose of alerts is to inform the user about critical information and optionally to force the user to make a decision about some action.&lt;/p&gt;

&lt;p&gt;An alert view does always contain a title text, which should not be longer than one line and one (for pure informational alerts, e.g., „OK“) or two (for alerts that require a decision, e.g., „Send“ and „Cancel“) buttons.&lt;/p&gt;

&lt;p&gt;iOS Alerts &lt;br /&gt;
Also, you can add a message text, if needed, as well as up to two text input fields, one of which can be a masked input field, which is appropriate for sensitive information like passwords or PINs.&lt;/p&gt;

&lt;p&gt;EDIT MENU&lt;/p&gt;

&lt;p&gt;iOS minimal search bar &lt;br /&gt;
The Edit Menu allows users to perform actions such as Copy, Paste, Cut, etc., when an element is selected (text, images, others). While it is possible to control which operations the user can choose from, the visual appearance of edit menus is set and not configurable unless you build your own completely custom edit menu.&lt;/p&gt;

&lt;p&gt;POPOVER&lt;/p&gt;

&lt;p&gt;Popovers are useful when a specific action requires multiple user inputs before proceeding. A good example is adding an item, which has a few attributes that need to be set before the item can be created.&lt;/p&gt;

&lt;p&gt;In a horizontal environment, popovers reveal underneath the related control (such as a button) with an arrow pointing to that control while opened. The background of a popover uses a slightly reduced opacity and blurs the content underneath, just as many other UI elements have done since iOS 7.&lt;/p&gt;

&lt;p&gt;iOS popover view &lt;br /&gt;
A popover is a powerful temporary view that can contain various objects such as its own navigation bar, table views, maps or web views. When a popover grows in size due to the number of contained elements and reaches the bottom edge of the viewport, it is possible to scroll within the popover.&lt;/p&gt;

&lt;p&gt;MODALS&lt;/p&gt;

&lt;p&gt;Modals are a useful view for tasks that require multiple commands or inputs by the user. They appear on top of everything else, and, while open, block interaction with any other interactive elements underneath.&lt;/p&gt;

&lt;p&gt;The typical modal usually provides:&lt;/p&gt;

&lt;p&gt;a title to describe the task;&lt;br /&gt;
a button to close the modal without saving or performing any other actions;&lt;br /&gt;
a button to save or submit any entered information; and&lt;br /&gt;
various elements for user input in the modal body.&lt;br /&gt;
There are three different modal styles available:&lt;/p&gt;

&lt;p&gt;Full screen: covers the entire screen.&lt;br /&gt;
Page sheet: In portrait mode, the modal covers the underlaying content only partially, leaving a small portion of the parent view visible underneath the translucent black background. In landscape mode, the page sheet modal acts just like a full screen modal.&lt;br /&gt;
Form sheet: In portrait mode, the modal appears in the center of the screen, keeping the surrounding content of the parent view visible underneath the translucent black background. The position of the modal adjusts automatically when a keyboard needs to be displayed. In landscape mode, the page sheet modal acts just like a full screen modal.&lt;br /&gt;
Controls&lt;/p&gt;

&lt;p&gt;iOS provides a wide range of controls for basically any required input type you can think of. Listed below you will find the most important (commonly used), but for a full list of the available controls, you should look at the iOS Developer Library.&lt;/p&gt;

&lt;p&gt;BUTTONS&lt;/p&gt;

&lt;p&gt;Probably the most used control overall is the good old button. Since iOS 7, the default button design hasn’t really looked like a button anymore, but rather more like a plain text link. The button control is highly customizable and allows you to style everything from text style, drop shadows and color to an icon that is either prepended or centered if there is no text label, as well as fully custom backgrounds.&lt;/p&gt;

&lt;p&gt;Keep in mind that a button can have several states, which should be communicated with visual language: default, highlighted, selected and disabled.&lt;/p&gt;

&lt;p&gt;PICKERS&lt;/p&gt;

&lt;p&gt;Pickers are used to select one value from a list of available values. The web equivalent would be a select box (which the picker control is also used for when touching a select in Safari). An extended version of picker is the datepicker, which allows the user to scroll through a list of dates and times and select values for (configurable) day, month and time.&lt;/p&gt;

&lt;p&gt;iOS picker controls&lt;br /&gt;
Left: datepicker displayed inside a table view, right: picker as keyboard.&lt;br /&gt;
Except for the background color, it is not possible to change the visual style or size (same as keyboard) of a picker control. Most often, they appear at the bottom of the screens, where keyboards appear as well, but it is possible to use them in other positions.&lt;/p&gt;

&lt;p&gt;SEGMENT CONTROLS&lt;/p&gt;

&lt;p&gt;A segment control contains a set of segments (at least two) that can be used for things like filtering content or to create tabs for clearly categorized content types.&lt;/p&gt;

&lt;p&gt;iOS segment controls &lt;br /&gt;
Segment control without and with icons.&lt;br /&gt;
Each segment can contain a text label or an image (icon), but never both. In addition, using a mixed set of segment types (text and images) in one segment control is not really recommended. The width of one segment changes automatically based on the number of segments (two segments: 50% of total control width, 5 segments: 20% of total control width).&lt;/p&gt;

&lt;p&gt;SLIDERS&lt;/p&gt;

&lt;p&gt;The slider control allows the user to choose one specific value from a range of allowed values. Since choosing a value works pretty smoothly and without any steps, sliders are recommended for selecting an estimated, but not exact, value. For example, a slider would be a good control for setting the sound volume, since the user can hear the difference and can see the difference between loud and very loud, but a text input to set an exact dB value would be impractical.&lt;/p&gt;

&lt;p&gt;iOS slider controls &lt;br /&gt;
Slider control without and with descriptive icons.&lt;br /&gt;
It is possible to set icons for the minimum and the maximum value, which are displayed on the start and end edge of the slider control, thereby allowing you to visually embrace the purpose of the slider.&lt;/p&gt;

&lt;p&gt;STEPPER&lt;/p&gt;

&lt;p&gt;Steppers should be used when the user should enter an exact value from a limited range of possible values (e.g., 1-10). A stepper always contains two segmented buttons, one for lowering and one for raising the current value.&lt;/p&gt;

&lt;p&gt;iOS stepper controls &lt;br /&gt;
Visually, the stepper control is highly customizable:&lt;/p&gt;

&lt;p&gt;you can use your own icons for stepper buttons;&lt;br /&gt;
when maintaining the native iOS look, you can customize the color of borders, background and icons by using a tint color, which automatically sets the color for each of these elements; and&lt;br /&gt;
if you want to go further, you can use completely custom background images for the stepper buttons as well as for the separator.&lt;br /&gt;
SWITCH&lt;/p&gt;

&lt;p&gt;iOS switch controls &lt;br /&gt;
A switch allows the user to quickly toggle between two possible states: on and off. It’s the checkbox for iOS apps. It is possible to customize the color for the on and off states, but the appearance of the toggle button and size of the switch are set and cannot be changed.&lt;/p&gt;

&lt;p&gt;KEYBOARDS&lt;/p&gt;

&lt;p&gt;There are various keyboard types available to provide the best possible keyboard for a specific text input. While it is possible to build your own completely custom keyboard, default keyboards cannot be customized in style or size.&lt;/p&gt;

&lt;p&gt;Further Reading and Resources&lt;/p&gt;

&lt;p&gt;These guidelines only provide basic information to get you started with iOS design. Once you dig deeper, you might be interested in more details. These articles and resources should help you.&lt;/p&gt;

&lt;p&gt;GENERAL&lt;/p&gt;

&lt;p&gt;iOS Human Interface Guidelines&lt;br /&gt;
by Apple&lt;br /&gt;
UIKit User Interface Catalog&lt;br /&gt;
by Apple&lt;br /&gt;
My app design workflow&lt;br /&gt;
by Marc Edwards&lt;br /&gt;
Learn Mobile App Design&lt;br /&gt;
on Treehouse&lt;br /&gt;
ANIMATIONS &amp;amp; PROTOTYPING&lt;/p&gt;

&lt;p&gt;Principle&lt;br /&gt;
$99, highly recommended!&lt;br /&gt;
Framer.js&lt;br /&gt;
$79.99, trial available&lt;br /&gt;
Marvel&lt;br /&gt;
Free Prototyping for Everyone&lt;br /&gt;
Pixate&lt;br /&gt;
Prototype iOS animations&lt;br /&gt;
How To Prototype In Xcode Using Storyboard&lt;br /&gt;
by Meng To&lt;br /&gt;
DEVELOPMENT STARTER GUIDES&lt;/p&gt;

&lt;p&gt;Building iOS Apps From Scratch&lt;br /&gt;
by Mike Rundle&lt;br /&gt;
Cocoa Controls&lt;br /&gt;
Open Source, Commercial&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Jan 2015 20:00:00 +0800</pubDate>
        <link>http://emotion.net.cn/2015/01/29/resolution/</link>
        <guid isPermaLink="true">http://emotion.net.cn/2015/01/29/resolution/</guid>
        
        <category>apple</category>
        
        
      </item>
    
      <item>
        <title>redhat init script</title>
        <description>&lt;p&gt;redhat启动脚本顺序&lt;br /&gt;
加载内核&lt;br /&gt;
执行init程序&lt;br /&gt;
/etc/rc.d/rc.sysinit&lt;br /&gt;
			#调入keymap及系统字体&lt;br /&gt;
			#启动swapping&lt;br /&gt;
			#设置主机名&lt;br /&gt;
			#设置NIS域名&lt;br /&gt;
			#fsck 并mount文件系统&lt;br /&gt;
			#打开quota&lt;br /&gt;
			#装载声卡模块&lt;br /&gt;
			#设置系统时钟&lt;br /&gt;
/etc/rc.d/rc $RUNLEVEL	#/etc/inittab中设定$RUNLEVEL&lt;br /&gt;
			#执行相应等级目录下的脚本/etc/rc.d/rc3.d/Sxxx&lt;br /&gt;
/etc/rc.d/rc.local&lt;br /&gt;
/sbin/mingetty		#等待用户登录&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Jan 2015 20:00:00 +0800</pubDate>
        <link>http://emotion.net.cn/2015/01/29/redhat-init-script/</link>
        <guid isPermaLink="true">http://emotion.net.cn/2015/01/29/redhat-init-script/</guid>
        
        <category>linux</category>
        
        <category>kernel init</category>
        
        <category>script</category>
        
        
      </item>
    
      <item>
        <title>linux program</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;//错误处理&lt;/h1&gt;
&lt;p&gt;//&lt;errno.h&gt;中定义了变量errno&lt;/errno.h&gt;&lt;/p&gt;

&lt;p&gt;#include &lt;string.h&gt;
char* strerrno(int errno);		//指向消息字符串的指针&lt;/string.h&gt;&lt;/p&gt;

&lt;p&gt;#include &lt;stdio.h&gt;
void perror(const char* msg)	//输出以msg开头的错误信息，错误信息定义来自errno&lt;/stdio.h&gt;&lt;/p&gt;

&lt;p&gt;目录的读权限：对目录进行搜索的能力&lt;br /&gt;
目录的写权限：在目录中创建和删除文件的能力&lt;br /&gt;
目录的执行权限：打开或访问目录中包含的文件或子目录时搜索目录的能力&lt;/p&gt;

&lt;p&gt;粘着位sticky bit:t&lt;br /&gt;
如果文件设置了粘着位，那么只有文件的数组或root才可以删除该文件&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Jan 2015 20:00:00 +0800</pubDate>
        <link>http://emotion.net.cn/2015/01/29/prog-tmp/</link>
        <guid isPermaLink="true">http://emotion.net.cn/2015/01/29/prog-tmp/</guid>
        
        <category>linux prog</category>
        
        
      </item>
    
      <item>
        <title>signal</title>
        <description>&lt;p&gt;信号集的处理&lt;/p&gt;

&lt;p&gt;int sigemptyset(sigset_t &lt;em&gt;set); //创建set并且情况信号集&lt;br /&gt;
int sigfillset(sigset_t *set); //创建set并使set包含所有linux的信号&lt;br /&gt;
int addset(sigset_t *set,int signo);      //给set信号集增加一个signo信号&lt;br /&gt;
int sigdelset(sigset_t&lt;/em&gt;set,int signo); //将set信号集中的signo定义的信号剔除&lt;/p&gt;

&lt;p&gt;以上四个函数成功调用返回0,失败返回1&lt;/p&gt;

&lt;p&gt;int sigismember(const sigset_t *set,int signo); //判断set信号集中是否已经包含signo所指向的信号,真返回1,假返回0&lt;br /&gt;
int sigprocmask(int how,const sigset_t *set,sigset_t *oset);    //设置信号集的屏蔽位,如果oset不为NULL,则oset返回当前修改之前的屏蔽字&lt;br /&gt;
how的参数定义&lt;br /&gt;
SIG_BLOCK : 屏蔽set所包含的所有信号&lt;br /&gt;
SIG_UNBLOCK : 解除set所包含的所有信号&lt;br /&gt;
SIG_SETMASK : 直接设置屏蔽信号所指向的值给set信号集&lt;/p&gt;

&lt;p&gt;int sigaction(int signo,const struct sigction &lt;em&gt;act,struct sigaction *oact);&lt;br /&gt;
sigaction函数的功能是检测或者修改signo信号关联的处理动作&lt;br /&gt;
signo是要检测或者修改具体动作的信号编号数,若act非NULL,则修改它的动作,如果oact非NULL,则返回该信号的原先动作&lt;br /&gt;
struct sigaction{&lt;br /&gt;
void (&lt;/em&gt;sa_handler)(int signo); //用户自定义处理函数,或者SIG_DFL或者 SIG_IGN&lt;br /&gt;
sigset_t sa_mask;       //信号集,用来指导在信号处理指向过程中哪些信号要被阻塞&lt;br /&gt;
int sa_flags;   //信号选项,包括是否则色,是否忽略SIGSTOP,SIGSTP,SIGTTIN,SIGTTOU信号,是否自定义信号只执行一次等等&lt;br /&gt;
void (*as_restore);       &lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;int sigpending(sigset_t *set); //用于检测set信号集中是否为未决的信号,比如在信号集阻塞时的信号&lt;/p&gt;

&lt;p&gt;sa_restorer已过时，POSIX不支持它，不应再使用。&lt;/p&gt;

&lt;p&gt;当你的信号需要接收附加信息的时候，你必须给sa_sigaction赋信号处理函数指针，同时还要给sa_flags赋SA_SIGINFO, 如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          sigemptyset(&amp;amp;sig_act.sa_mask);
          sig_act.sa_sigaction=sig_handler_with_arg;
          sig_act.sa_flags=SA_SIGINFO; 如果你的应用程序只需要接收信号，而不需要接收额外信息，那你需要的设置的是sa_handler,而不是sa_sigaction，如下：
          sigemptyset(&amp;amp;sig_act.sa_mask);
          sig_act.sa_handler=sig_handler;
          sig_act.sa_flags=0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新版本&lt;br /&gt;
信号发送函数sigqueue()及信号安装函数sigaction()&lt;/p&gt;

&lt;p&gt;信号值位于SIGRTMIN和SIGRTMAX之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。&lt;br /&gt;
这些信号支持排队，不会丢失。&lt;/p&gt;

&lt;p&gt;信号阻塞：当信号发生而无法处理的时候，不要忽略该信号，在进程准备好时再通知它&lt;br /&gt;
信号产生到在进程上标记标志之间，信号未决(pending)&lt;/p&gt;

&lt;p&gt;三个函数改变信号屏蔽字&lt;br /&gt;
sigpending将制定的哦信号设置为阻塞和pending&lt;br /&gt;
sigprocmask查询和设置当前进程的信号屏蔽字&lt;br /&gt;
sigsuspend在原子操作中实现恢复信号屏蔽字,并且使进程睡眠&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Jan 2015 20:00:00 +0800</pubDate>
        <link>http://emotion.net.cn/2015/01/29/prog-signal/</link>
        <guid isPermaLink="true">http://emotion.net.cn/2015/01/29/prog-signal/</guid>
        
        <category>linux prog</category>
        
        
      </item>
    
      <item>
        <title>io</title>
        <description>&lt;h1 id=&quot;io&quot;&gt;//文件IO&lt;/h1&gt;
&lt;p&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;br /&gt;
#include &amp;lt;sys/stat.h&amp;gt;&lt;br /&gt;
#include &lt;fcntl.h&gt;
int open(const char* pathname, int oflag, .../*, mode_t mods */);	//返回文件描述符
	oflag
	O_RDONLY	0	只读
	O_WRONLY	1	只写
	O_RDWR		2	读写
	O_APPEND		写到文件尾
	O_CREAT			若不存在则创建，需要创建mods
	O_EXCL			同时指定O_CREAT， 文件存在则出错，文件不存在则创建
	O_TRUNC			若文件存在，且只读或只写打开，则文件长度截短为0
	O_NOCTTY		若打开终端设备，则不将此设备分配为此进程的控制终端
	O_NONBLOCK		若打开FIFO、块文件、字符文件，为此文件的本次打开操作和后续的IO操作设置非阻塞方式
	O_SYNC			每次write都等到物理IO完成才返回，同步&lt;/fcntl.h&gt;&lt;/p&gt;

&lt;p&gt;===============================================&lt;br /&gt;
#include &amp;lt;sys/types.h&amp;gt;&lt;br /&gt;
#include &amp;lt;sys/stat.h&amp;gt;&lt;br /&gt;
#icnlude &lt;fcntl.h&gt;&lt;/fcntl.h&gt;&lt;/p&gt;

&lt;p&gt;int creat(const char* pathname, mode_t mode);		//返回文件描述符&lt;br /&gt;
open(pathname, O_WRONLY|O_CREAT|O_TRUNC, mode);		//等价于&lt;/p&gt;

&lt;p&gt;===============================================&lt;br /&gt;
#include &lt;unistd.h&gt;
int close(int filedes);		//成功:0, 出错:-1&lt;/unistd.h&gt;&lt;/p&gt;

&lt;p&gt;===============================================&lt;br /&gt;
#include &amp;lt;sys/types.h&amp;gt;&lt;br /&gt;
#include &lt;unistd.h&gt;&lt;/unistd.h&gt;&lt;/p&gt;

&lt;p&gt;off_t lseek(int filedes, off_t offset, int whence);		//如果文件为管道文件或FIFO，返回-1&lt;br /&gt;
//whence&lt;br /&gt;
//SEEK_SET	设置文件当前位置为 文件开始+offset，offset取正值&lt;br /&gt;
//SEEK_CUR	设置文件当前位置为 当前位置+offset，offset取正负值&lt;br /&gt;
//SEEK_END	设置文件当前位置为 文件长度+offset，offset取正负值&lt;/p&gt;

&lt;p&gt;off_t currpos = lseek(fd, 0, SEEK_CUR);		//获取文件当前位置&lt;br /&gt;
//如果文件为管道文件或FIFO，返回-1&lt;br /&gt;
//lseek不引起文件IO&lt;br /&gt;
//文件位移可以大于文件长度，对该文件的下一次写将延长文件，并留下空洞&lt;/p&gt;

&lt;p&gt;===============================================&lt;br /&gt;
#include &lt;unistd.h&gt;
ssize_t read(int filedes, void *buff,  size_t nbytes);		//返回读到的字节数，0为文件尾&lt;/unistd.h&gt;&lt;/p&gt;

&lt;p&gt;//从终端设备读时，一次最多读一行&lt;br /&gt;
//从网络读时，最多读取缓冲中的字符数&lt;/p&gt;

&lt;p&gt;#include &lt;unistd.h&gt;
ssize_t write(int filedes, const void* buff, size_t nbytes);	//返回已写的字节数&lt;/unistd.h&gt;&lt;/p&gt;

&lt;p&gt;===============================================&lt;br /&gt;
#include &lt;unistd.h&gt;
int dup(int filedes);	//返回当前最小的可用文件描述符
			//等效于fcntl(filedes, F_DUPFD, 0);
int dup2(int filedes, int filedes2);		//已filedes2指定新描述符的数值, 如果filedes2已经打开，先将其关闭
			//等效于close(filedes2); fcntl(filedes, F_DUPFD, filedes2);&lt;/unistd.h&gt;&lt;/p&gt;

&lt;p&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;br /&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;&lt;/fcntl.h&gt;&lt;/unistd.h&gt;&lt;/p&gt;

&lt;p&gt;int fcntl(int filedes, int cmd, … /* int arg */);	&lt;br /&gt;
	cmd&lt;br /&gt;
	F_DUPFD		//复制现存的描述符， 		返回新文件描述符&lt;br /&gt;
	F_GETFD		//获得/设置文件描述符标志	返回文件描述符标志&lt;br /&gt;
	F_SETFD		&lt;br /&gt;
	F_GETFL		//获得/设置文件状态标志		&lt;br /&gt;
	F_SETFL		&lt;br /&gt;
	F_GETOWN	//获得/设置异步I/O有权&lt;br /&gt;
	F_SETOWN&lt;br /&gt;
	F_GETLK		//获得/设置记录锁&lt;br /&gt;
	F_SETLK&lt;br /&gt;
	F_SETLKW&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;F_GETFL/F_SETFL
文件状态标志位
O_RDONLY	//只读打开
O_WRONLY	//只写打开
O_RDWR		//读写打开,	这三个的掩码为O_ACCMODE
O_APPEND	//写时添加至文件尾
O_NONBLOCK	//非阻塞方式
O_YNC		//等待写完成
O_ASYNC		//异步IO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;======================================================================================&lt;br /&gt;
#include &lt;unistd.h&gt;
#include &amp;lt;sys/ioctl.h&amp;gt;&lt;/unistd.h&gt;&lt;/p&gt;

&lt;p&gt;int ioctl(int filedes, int request, …);&lt;/p&gt;

&lt;p&gt;======================================================================================&lt;/p&gt;

</description>
        <pubDate>Thu, 29 Jan 2015 20:00:00 +0800</pubDate>
        <link>http://emotion.net.cn/2015/01/29/prog-io-basic/</link>
        <guid isPermaLink="true">http://emotion.net.cn/2015/01/29/prog-io-basic/</guid>
        
        <category>linux prog</category>
        
        
      </item>
    
      <item>
        <title>Linux dir</title>
        <description>&lt;p&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;br /&gt;
#include &amp;lt;sys/stat.h&amp;gt;&lt;/p&gt;

&lt;p&gt;int stat(const char* pathname, struct stat* buf);&lt;br /&gt;
int fstat(int filedes, struct stat* buf);&lt;br /&gt;
int lstat(const char* pathname, struct stat* buf);&lt;/p&gt;

&lt;p&gt;struct stat {&lt;br /&gt;
	mode_t 	st_mode;	//file type &amp;amp; mode&lt;br /&gt;
	ino_t	st_ino;		//inode number&lt;br /&gt;
	dev_t	st_dev;		//device number&lt;br /&gt;
	dev_t	st_rdev;	//device number for special files&lt;br /&gt;
	nlink_t	st_nlink;	//number of links&lt;br /&gt;
	uid_t	st_uid;		//user id for owner&lt;br /&gt;
	gid_t	st_gid;		//group id for owner&lt;br /&gt;
	off_t	st_size;	//size in bytes, for regular files&lt;br /&gt;
	time_t	st_atimve;	//time of last access&lt;br /&gt;
	time_t 	st_mtime;	//time of last modification&lt;br /&gt;
	time_t	st_ctime;	//time of last file status change&lt;br /&gt;
	long	st_blksize;	//best IO block size&lt;br /&gt;
	long	st_blocks;	//number of 512-byte blocks allocated&lt;br /&gt;
}&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;文件类型				|&lt;br /&gt;
————————|&lt;br /&gt;
&amp;lt;sys/stat.h&amp;gt;			|&lt;br /&gt;
————————|&lt;br /&gt;
S_ISREG(st_mode)		|&lt;br /&gt;
S_ISDIR(st_mode)		|&lt;br /&gt;
S_ISCHR(st_mode)		|&lt;br /&gt;
S_ISBLK(st_mode)		|&lt;br /&gt;
S_ISFIFO(st_mode)		|&lt;br /&gt;
S_ISLNK(st_mode)		|&lt;br /&gt;
S_ISSOCK(st_mode)		|	&lt;br /&gt;
————————&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;用户ID							|&lt;br /&gt;
——————————-	|&lt;br /&gt;
实际uid		实际上是谁			|&lt;br /&gt;
实际gid							|&lt;br /&gt;
——————————-	|&lt;br /&gt;
有效uid		用于文件许可权检查	|&lt;br /&gt;
有效gid							|&lt;br /&gt;
添加gid							|&lt;br /&gt;
——————————-	|&lt;br /&gt;
保存设置uid	由exec函数保存		|&lt;br /&gt;
保存设置gid						|&lt;br /&gt;
——————————–&lt;/p&gt;

&lt;p&gt;======================================================================&lt;br /&gt;
#include &lt;unistd.h&gt;
int access(const char* pathname, int mode);	//成功返回0
	mode
	R_OK	//读许可权
	W_OK	//写许可权
	X_OK	//执行许可权
	F_OK	//文件是否存在&lt;/unistd.h&gt;&lt;/p&gt;

&lt;p&gt;======================================================================&lt;br /&gt;
#include &amp;lt;sys/types.h&amp;gt;&lt;br /&gt;
#include &amp;lt;sys/stat.h&amp;gt;&lt;/p&gt;

&lt;p&gt;mode_t umask(mode_t cmask);	//返回旧屏蔽字，将cmask中指定的权限从后续的文件操作中去掉&lt;br /&gt;
	cmask&lt;br /&gt;
	S_IRUSR		//用户-读&lt;br /&gt;
	S_IWUSR		//用户-写&lt;br /&gt;
	S_IXUSR		//用户-执行&lt;br /&gt;
	S_IRGRP		//组-读&lt;br /&gt;
	S_IWGRP		//组-写&lt;br /&gt;
	S_IXGRP		//组-执行&lt;br /&gt;
	S_IROTH		//其他-读&lt;br /&gt;
	S_IWOTH		//其他-写&lt;br /&gt;
	S_IXOTH		//其他-执行&lt;/p&gt;

&lt;p&gt;======================================================================&lt;br /&gt;
#include &amp;lt;sys/types.h&amp;gt;&lt;br /&gt;
#include &amp;lt;sys/stat.h&amp;gt;&lt;/p&gt;

&lt;p&gt;int chmode(const char* pathname, mode_t mode);&lt;br /&gt;
int fchmod(int filedes, mode_t mode);&lt;br /&gt;
	mode&lt;br /&gt;
	S_ISUID&lt;br /&gt;
	S_ISGID&lt;br /&gt;
	S_ISVTX&lt;br /&gt;
	S_IRWXU	= S_IRUSR S_IWUSR S_IXUSR&lt;br /&gt;
	S_IRWXG = S_IRGRP S_IWGRP S_IXGRP&lt;br /&gt;
	S_IRWXO = S_IROTH S_IWOTH S_IXOTH&lt;/p&gt;

&lt;p&gt;======================================================================&lt;br /&gt;
#include &amp;lt;sys/types.h&amp;gt;&lt;br /&gt;
#include &lt;unistd.h&gt;&lt;/unistd.h&gt;&lt;/p&gt;

&lt;p&gt;int chown(const char* pathname, uid_t owner, gid_t group);&lt;br /&gt;
int fchown(int filedes, uid_t owner, gid_t group);&lt;br /&gt;
int lchown(const char* pathname, uid_t owner, gid_t group);&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;文件截断&lt;/h1&gt;
&lt;p&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;br /&gt;
#include &lt;unistd.h&gt;&lt;/unistd.h&gt;&lt;/p&gt;

&lt;p&gt;int truncate(const char* pathname, off_t length);&lt;br /&gt;
int ftruncate(int filedes, off_t length);&lt;/p&gt;

&lt;p&gt;======================================================================&lt;br /&gt;
#inlcude &lt;unistd.h&gt;
int link(const char* existingpath, const char* newpath);&lt;/unistd.h&gt;&lt;/p&gt;

&lt;p&gt;#include &lt;unistd.h&gt;
int unlink(const char* pathname);		//删除一个现存的目录项&lt;/unistd.h&gt;&lt;/p&gt;

&lt;p&gt;#include &lt;stdio.h&gt;
int remove(const char* pathname);		//对文件与unlink函数相同，对于目录与rmdir函数相同&lt;/stdio.h&gt;&lt;/p&gt;

&lt;p&gt;#include &lt;stdio.h&gt;
int rename(const char* oldname, const char* newname);&lt;/stdio.h&gt;&lt;/p&gt;

&lt;p&gt;#include &lt;unistd.h&gt;
int symlink(const char* acutualpath, const char* sympath);	//创建链接
int readlink(const char* pathname, char buf, int bufsize);	//组合了open，read，close&lt;/unistd.h&gt;&lt;/p&gt;

&lt;p&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;br /&gt;
#include &lt;utime.h&gt;
int utime(const char* pathname, const struct utimebuf times);	//文件的存取/修改时间&lt;/utime.h&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 29 Jan 2015 20:00:00 +0800</pubDate>
        <link>http://emotion.net.cn/2015/01/29/prog-dir/</link>
        <guid isPermaLink="true">http://emotion.net.cn/2015/01/29/prog-dir/</guid>
        
        <category>linux prog</category>
        
        
      </item>
    
      <item>
        <title>vfs</title>
        <description>&lt;h2 id=&quot;vfs&quot;&gt;VFS&lt;/h2&gt;
&lt;p&gt;sys_read&lt;br /&gt;
	current-&amp;gt;file-&amp;gt;f_op-&amp;gt;read();&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;超级块对象&lt;/h2&gt;
&lt;p&gt;struct supper_block&lt;br /&gt;
{&lt;br /&gt;
	struct list_head 	s_list;		//把supper_block连接在一起,全局super_blocks&lt;br /&gt;
	kdev_t			s_dev;&lt;br /&gt;
	struct list_head	s_dirty;	//脏inode节点, link by inode-&amp;gt;i_list&lt;br /&gt;
}&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;索引节点对象&lt;/h2&gt;
&lt;p&gt;struct inode&lt;br /&gt;
{&lt;br /&gt;
	struct list_head	i_hash;&lt;br /&gt;
	struct list_head	i_list;		//放在全局列表中&lt;br /&gt;
	struct list_head	i_dentry;	//每个inode可能存在多个目录项&lt;br /&gt;
}&lt;br /&gt;
索引节点对文件是唯一的，随文件存在而存在。&lt;/p&gt;

&lt;p&gt;全局列表	//link by inode-&amp;gt;i_list&lt;br /&gt;
inode_in_use	//inode.i_count &amp;gt; 0; 页面不脏;的inode存在于这个列表中&lt;br /&gt;
inode_unused	//inode.i_count - 0; 页面不脏;的inode存在于这个列表中&lt;br /&gt;
anon_hash_chain	//inodes with NULL i_sb;&lt;br /&gt;
sb-&amp;gt;i_dirty	//脏inode&lt;/p&gt;

&lt;p&gt;全局hash表&lt;br /&gt;
static struct list_head *inode_hashtable;//inode-&amp;gt;i_hash解决hash冲突&lt;/p&gt;

&lt;h2 id=&quot;file&quot;&gt;file对象&lt;/h2&gt;
&lt;p&gt;描述进程怎样与打开的文件交互，文件对象爱你个在文件被打开时创建&lt;br /&gt;
struct file&lt;br /&gt;
{&lt;br /&gt;
	struct list_head	f_list;&lt;br /&gt;
	sturct dentry*		f_dentry;&lt;br /&gt;
	struct vfsmount*	f_vfsmnt;&lt;br /&gt;
	struct file_operations*	f_op;&lt;br /&gt;
	unsigned int 		f_count;	//引用计数&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;全局列表 	//link by file-&amp;gt;f_list&lt;br /&gt;
free_list	//”未使用”file对象列表，可作为file对象的cache, file-&amp;gt;f_count = 0;&lt;br /&gt;
anon_list	//”在使用”但未分配给超级块的file对象，file-&amp;gt;f_count = 1;&lt;br /&gt;
sb-&amp;gt;s_files	//”在使用”已分配给超级块的file对象&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;目录项对象&lt;/h2&gt;
&lt;p&gt;路径中的每一部分都对应于一个dentry对象&lt;br /&gt;
存在于名为dentry_cache的slab中&lt;br /&gt;
struct dentry&lt;br /&gt;
{&lt;br /&gt;
	struct inode*		d_inode;&lt;br /&gt;
	struct dentry*		d_parent;&lt;br /&gt;
	struct list_head 	d_hash;		//link in dentry_hash&lt;br /&gt;
	struct list_head 	d_lru;		//link in 未使用队列&lt;br /&gt;
	struct list_head 	d_child;	//link in 父目录项&lt;br /&gt;
	struct list_head 	d_subdirs;	//子目录项列表&lt;br /&gt;
	struct list_head 	d_alias;	//link in inode&lt;br /&gt;
	struct qstr 		d_name;		//文件名&lt;br /&gt;
	unsigned char		d_iname;	//短文件名&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;全局列表		//dentry-&amp;gt;d_list&lt;br /&gt;
inode-&amp;gt;i_dentry		//在使用的，link by dentry-&amp;gt;d_alias，一个inode可能有多个dentry&lt;br /&gt;
dentry_unused;		//未使用的LRU列表, link by dentry-&amp;gt;d_lru&lt;br /&gt;
负状态&lt;/p&gt;

&lt;p&gt;全局hash表&lt;br /&gt;
dentry_hashtable&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;进程相关结构&lt;/h2&gt;
&lt;p&gt;struct fs_struct			//表示进程与文件系统交互所需信息,task-&amp;gt;fs&lt;br /&gt;
{&lt;br /&gt;
	atomic_t 	count;&lt;br /&gt;
	struct dentry*	root;&lt;br /&gt;
	struct dentry*	pwd;&lt;br /&gt;
	struct dentry*	altroot;&lt;br /&gt;
	struct vfsmount&lt;em&gt;rootmnt;&lt;br /&gt;
	struct vfsmount&lt;/em&gt;pwdmnt;&lt;br /&gt;
	struct vfsmount*altrootmnt;&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;struct files_struct			//表示进程当前打开的文件,task-&amp;gt;files&lt;br /&gt;
{&lt;br /&gt;
	atomic_t	count;&lt;br /&gt;
	struct file**	fd;&lt;br /&gt;
	struct file**	fd_array;&lt;br /&gt;
}&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;文件系统类型对象&lt;/h2&gt;
&lt;p&gt;struct file_system_type&lt;br /&gt;
{&lt;br /&gt;
	super_block* (*)()	read_super;	//读取该文件系统超级块的方法&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;全局&lt;br /&gt;
static struct file_system_type *file_systems;&lt;br /&gt;
register_filesystem();			//将file_system_type放入全局列表file_systems中，每个文件系统不能有相同文件名&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;已安装的文件系统对象&lt;/h2&gt;
&lt;p&gt;struct vfsmount&lt;br /&gt;
{&lt;br /&gt;
	struct list_head mnt_hash;&lt;br /&gt;
	struct vfsmount *mnt_parent;&lt;br /&gt;
	struct dentry *mnt_mountpoint;&lt;br /&gt;
	struct dentry *mnt_root;&lt;br /&gt;
	struct super_block *mnt_sb;&lt;br /&gt;
	struct list_head mnt_mounts;	//子文件系统的列表&lt;br /&gt;
	struct list_head mnt_child;	//link in 父文件系统的mnt_mounts;&lt;br /&gt;
	struct list_head mnt_list;&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;全局列表&lt;/p&gt;

&lt;p&gt;全局hashtable&lt;br /&gt;
mount_hashtable;	//vfsmount-&amp;gt;mnt_hash解决hash冲突&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;路径名查找&lt;/h2&gt;
&lt;p&gt;struct nameidata {&lt;br /&gt;
	struct dentry *dentry;&lt;br /&gt;
	struct vfsmount *mnt;&lt;br /&gt;
	struct qstr last;&lt;br /&gt;
	unsigned int flags;&lt;br /&gt;
	int last_type;&lt;br /&gt;
};&lt;/p&gt;

&lt;p&gt;path_init&lt;br /&gt;
path_walk&lt;br /&gt;
path_release&lt;/p&gt;

&lt;p&gt;__user_walk;(char* name, nameidata* nd)		//作为wrap函数，被很多系统调用使用&lt;br /&gt;
	-getname;	//从用户空间获得数据&lt;br /&gt;
	-path_lookup&lt;br /&gt;
		-path_init&lt;br /&gt;
			-walk_init_root&lt;br /&gt;
		-path_wakk&lt;br /&gt;
	-putname;&lt;/p&gt;

&lt;p&gt;传到path_init的name是一个文件路径&lt;br /&gt;
path_init()根据name是从根目录开始还是从当前目录开始，初始化nd-&amp;gt;mnt, nd-&amp;gt;dentry,指定搜索的起始位置&lt;br /&gt;
	如果从根目录开始，调用walk_init_root&lt;br /&gt;
	如果从相对目录开始，nd-&amp;gt;mnt = current-&amp;gt;fs-&amp;gt;pwdmnt; nd-&amp;gt;dentry = current-&amp;gt;fs-&amp;gt;pwd&lt;br /&gt;
path_walk()&lt;br /&gt;
	-link_path_walk&lt;br /&gt;
		-permission	//inode检查MAY_EXEC权限&lt;br /&gt;
		-follow_dotdot	//查看上层目录&lt;br /&gt;
				//开始搜索目录&lt;br /&gt;
		-cached_lookup	&lt;br /&gt;
			-d_lookup	//dentry_hashtable&lt;br /&gt;
		-real_lookup	&lt;br /&gt;
			-d_alloc	//从dentry_cache分配一个目录项，初始化&lt;br /&gt;
			-parent-&amp;gt;d_inode-&amp;gt;i_op-&amp;gt;lookup(parent-&amp;gt;d_inode, dentry)&lt;br /&gt;
					//通过父节点inode读取dentry&lt;br /&gt;
					//即ext2_lookup&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;文件系统的安装&lt;/h2&gt;
&lt;p&gt;struct namespace {&lt;br /&gt;
	atomic_t		count;&lt;br /&gt;
	struct vfsmount *	root;&lt;br /&gt;
	struct list_head	list;&lt;br /&gt;
	struct rw_semaphore	sem;&lt;br /&gt;
};&lt;/p&gt;

&lt;p&gt;三个mount函数&lt;br /&gt;
sys_mount			//系统调用&lt;br /&gt;
	copy_mount_options&lt;br /&gt;
	do_mount&lt;br /&gt;
		do_remount&lt;br /&gt;
		do_loopback	//建立/dev/loop0与普通文件之间的关系，命令losetup&lt;br /&gt;
		do_move_mount&lt;br /&gt;
		do_add_mount&lt;br /&gt;
mount_root			//init进程-&amp;gt;prepare_namespace-&amp;gt;mount_root&lt;br /&gt;
	devfs_make_root&lt;br /&gt;
	create_dev(“/dev/root”,);&lt;br /&gt;
	rd_load_disk&lt;br /&gt;
	mount_block_root&lt;br /&gt;
kern_mount			//安装特殊文件系统&lt;br /&gt;
	do_kern_mount&lt;/p&gt;

&lt;p&gt;1、安装根文件系统&lt;br /&gt;
start_kernel-&amp;gt;mnt_init&lt;br /&gt;
	init_rootfs&lt;br /&gt;
		-register_filesystem(“rootfs”)&lt;br /&gt;
	init_mount_tree&lt;br /&gt;
		-do_kernel_mount&lt;br /&gt;
			-type = get_fs_type&lt;br /&gt;
			-mnt = alloc_vfsmnt&lt;br /&gt;
			-sb = 	get_sb_bdev	这里复杂,常规文件系统&lt;br /&gt;
				get_sb_single	&lt;br /&gt;
				get_sb_nodev	无设备文件系统&lt;br /&gt;
				-path_lookup&lt;br /&gt;
				-fs_type-&amp;gt;read_super&lt;br /&gt;
				-path_release&lt;/p&gt;

&lt;p&gt;2、安装一般文件系统&lt;br /&gt;
sys_mount&lt;br /&gt;
	do_mount&lt;/p&gt;

&lt;p&gt;卸载文件系统&lt;br /&gt;
umount&lt;/p&gt;

&lt;p&gt;__setup(“root=”, root_dev_setup);&lt;br /&gt;
	root_dev_setup&lt;/p&gt;

</description>
        <pubDate>Thu, 29 Jan 2015 20:00:00 +0800</pubDate>
        <link>http://emotion.net.cn/2015/01/29/kernel-vfs/</link>
        <guid isPermaLink="true">http://emotion.net.cn/2015/01/29/kernel-vfs/</guid>
        
        <category>linux kernel</category>
        
        
      </item>
    
  </channel>
</rss>
