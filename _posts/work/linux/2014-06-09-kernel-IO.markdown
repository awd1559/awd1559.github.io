---
layout:     post
title:      "io"
subtitle:   " \"io\""
date:       2014-06-09 12:00:00
author:     "awd"
header-img: "img/post-bg-2015.jpg"
tags:
    - linux kernel
---

IO管理
====================================================
三种总线类型
数据总线
地址总线
控制总线

struct resourc		//IO地址的一个范围
{
	const char *name;
	unsigned long start, end;
	unsigned long flags;
	struct resource *parent, *sibling, *child;
};

全局变量
ioport_resource
iomem_resource





字符设备
struct device_struct {
	const char * name;
	struct file_operations * fops;
};
static struct device_struct chrdevs[MAX_CHRDEV];
register_chrdev();			//注册字符设备
块设备
static struct {
	const char *name;
	struct block_device_operations *bdops;
} blkdevs[MAX_BLKDEV];
register_blkdev();			//注册块设备


struct block_device				//块设备描述符
{
	struct list_head	bd_hash;	//bdev_hash
	atomic_t		bd_count;	//引用计数
	struct inode *		bd_inode;	
	dev_t			bd_dev;
	const struct block_device_operations *bd_op;	//
}
static struct list_head bdev_hashtable;		//block_device块设备描述符hash表
bd_acquire(inode)
	-bdget	//从bdev_hash表中找到一个block_device
		//否则从bdev_cache的slab中初始化一个





缓冲区管理
------------------------------------------------------
struct buffer_head {
	/* First cache line: */
	struct buffer_head *b_next;	//解决hash_table中的hash冲突
	struct buffer_head **b_pprev;

	unsigned long b_blocknr;
	unsigned short b_size;
	unsigned short b_list;
	kdev_t b_dev;

	atomic_t b_count;		//引用计数
	kdev_t b_rdev;			
	unsigned long b_state;		//位图

	struct buffer_head *b_next_free;/* lru/free list linkage */ // link int unused_list
	struct buffer_head *b_prev_free;
	struct buffer_head *b_this_page;/* circular list of buffers in one page */
	struct buffer_head *b_reqnext;	/* request queue */

	char * b_data;
	struct page *b_page;
	void (*b_end_io)(struct buffer_head *bh, int uptodate);	//IO完成时调用的函数
 	void *b_private;					//函数参数

	unsigned long b_rsector;	/* Real buffer location on disk */
	wait_queue_head_t b_wait;

	struct list_head     b_inode_buffers;	/* doubly linked list of inode dirty buffers */
};

全局队列
struct buffer_head *lru_list[NR_LIST];
struct buffer_head * unused_list;		//未使用的缓冲区首部
						//未使用的buffer_head先放回unused_list;过多后放回slab


全局hash表
struct buffer_head **hash_table;













页高速缓存page cache
----------------------------------------
缓存一切基于page的对象，包括:
普通文件的数据
内存映射文件的数据
直接(跳过vfs)从块设备文件上读取的数据
包含已经交换到磁盘上的用户态进程数据的页
IPC共享先行区

在页和页上操作的方法之间建立联系的主要数据结构为address_space对象
每个address_space对象在普通的内核对象(owner，属主)和属主所在的页上操作的一组方法之间建立起一条链
owner大概有(inode, page, )

struct address_space {
	struct list_head	clean_pages;
	struct list_head	dirty_pages;
	struct list_head	locked_pages;		//三个列表头,address_space的own的所有page
	unsigned long		nrpages;		//总页数
	struct address_space_operations *a_ops;
	struct inode		*host;		/* owner: inode, block_device */owner 通常是一个inode
	struct vm_area_struct	*i_mmap;	/* list of private mappings */
	struct vm_area_struct	*i_mmap_shared; /* list of shared mappings */
	spinlock_t		i_shared_lock;  /* and spinlock protecting it */
	int			gfp_mask;	/* how to allocate the pages */
}



全局hash表
struct page **page_hash_table; 	//page_hash(宏得到hash槽)
add_page_to_hash_queue		//页放入page cache hashtable

add_page_to_inode_queue		//放入page cache对象address_space的clean_pages队列
remove_page_from_inode_queue


find_get_page(mapping, offset)	//从page_hash_table中找到一个页
add_to_page_cache(page)		//放入page_hash_table

find_or_create_page		//如果不存在, alloc_page

remove_inode_page		//从page cache中删除一个page


缓冲区高速缓存
------------------------------------------------
缓冲区放在名为缓冲区页(buffer pages)的专门页中，在一个单独缓冲区页中的所有缓冲区必须有相同的大小

grow_buffers		//分配buffer pages  见P494
	-grow_dev_page
		-find_or_create_page
		-create_buffers
getblk
	-get_hash_table		//从hash中找
	-grow_buffers		//增加buffer
	-free_more_memory	//如果不能增加，就释放内存
	



写脏缓冲区到磁盘-连个内核线程
bdflush
	write_some_buffers
		-get_bh
		-
kupdate
