---
layout:     post
title:      "linux"
subtitle:   " \"all about linux usage\""
date:       2014-06-09 12:00:00
author:     "awd"
header-img: "img/post-bg-2015.jpg"
tags:
    - linux
---

# shell

## awk

> - 逐行扫描
> - 匹配则执行命令
> - 匹配而未指定命令，则打印该行到屏幕

```
awk option '/patten/{action}' filenames
awk '/Sally/{print $1, $2}' datafile //print column 1 & 2
```

内置变量  |          |                |
value    | comment | default         |
-------- | ------- | --------------- |
ORS      |输入记录的分隔符(行分隔符) |换行符
RS       |输出记录的分隔符           |换行符
FS       |输入字段分隔符             |空格 
OFS      |输出字段分割符             |单个空格
NR       |每条记录的记录号           |
NF       |记录的字段数               |


```
awk '$1 ~ /Bill/' filename      #在第一个字段里匹配模式，而不是整行
awk '$2 !~ /Adam/' filename     #打印第二列不匹配模式的行
awk '$3 > 5000{print $1}' filename  #如果第三列>5000，打印第一列
awk '{max=($1 > $2) ?$1:$2; print max}' filename    #第一列和第二列中的值，打印值大的一列
awk '$3*$4 > 500' filename      #第三列和第四列乘积> 500的行输出
awk '$2 >5 && $2 <=15' filename     #并且
awk '/Tom/, /Suzanne/' filename     #范围

awk '$1 ~ /Tom/{wage = $2*$3;print wage}' filename  #定义变量
awk '$4>70 {print $1, $2 > "passing_file"}' filename    #重定向部分结果

awk 'BEGIN{"date"| getline d; print d}' filename    #getline函数从标准输入、管道、文件读取输入到变量d
awk 'BEGIN{"date"| getline d; split(d,mon); print mon[2]}' filename 
awk 'BEGIN{while("ls"|getline) print}' filename     #每循环一次，getline从ls中读取一行

awk 'BEGIN{printf "what is your name:"; \
getline name < "/dev/tty" }\                #读入查找的名字
$1 ~ name {print "Found " name " on line ", NR "."}\    #在第一个字段中查找
END{print "See ya, " name "."}' filename
```

## grep

```
grep 'pattern' filename     #基本RE元字符

grep -n '\.5s' datafile #输出符合模式的行，包含.5s的行

grep -G 'pattern' filename  #同上
grep -E 'pattern' filename  #扩展RE元字符，同egrep
grep -F 'pattern' filename  #非RE元字符，同fgrep
```


   | pattern          |
-- | ---------------- |
-n | #输出原文件中的行号 |
-i | #不区分大小写      |
-v | #输出不符合模式的行 |
-l | #只输出文件名      |
-w | #模式作用于词      |

- egrep 在grep元字符集上增加了更多的元字符
- fgrep 在linux中为grep -F, 没有元字符，模式中字符为字面含义


## sed

> - 逐行处理文本
> - 把正在处理的行保存到临时缓冲区，称为模式空间
> - 执行完sed命令后，将该行发送到屏幕，读取下一行
> - 还有一个暂存缓冲区(8192)，供hH存放，供gG读取


```
sed [options] 'command' file(s)  
```

```
sed '1,3d' file     #删除1-3行，其他行默认打印，不影响原文件
sed -n '/[Jj]ohn/p' file#打印符合模式的行，其他行不输出
```

   | options      |
-- | ------------ |
-e | 允许多项编辑   |
-f | 制定sed脚本   |
-n | 取消默认的输出 |

   | command
-- | ------------------------------------------------- |
a\ | #在当前行后添加一行和多行                             |
c\ | #替换                                              |
d  | #删除                                              |
i\ | #在当前行之前插入                                    |
h  | #模式空间里的内容复制到暂存缓冲区                       |
H  | #模式空间里的内容追加到暂存缓冲区                       |
g  | #用暂存缓冲区内容覆盖模式空间内容                       |
G  | #暂存缓冲区内容追加模式空间内容                         |
l  | #列出非打印字符                                      |
p  | #打印                                           |
n  | #读入下一行，并从下一条命令而不是第一条命令开始对其处理 |
q  | #退出sed                                       |
r  | #从文件中读取行到模式空间                          |
!  | #对所选行外的所有行应用命令                         |
s  | #字符串替换                                      |

  | 替换标志                      |
--| ---------------------------- |
g |  #在行内进行全局替换            |
p |  #打印                        |
w |  #将行写如文件                 |
x |  #交换暂存换种去与模式空间的内容  |
y |  #将字符转化为另一个字符         |


```
sed -e '1,3d' -e 's/Hemenway/Jones/' datafile
#多重编辑：删除1-3行，将Hemenway替换为Jones

sed '/Suan/r newfile' datafile
#匹配模式后，在该行后输出文件newfile中的内容

sed '/north/w newfile' datafile
#将模式匹配的行写入文件newfile中

sed '/^north/a \
this will added as next line ----' datafile
#匹配模式后，添加一行

sed '/eastern/{n; s/AM/Archie/;}' datafile
#匹配模式后，对下一行执行n中的命令
#多个命令组成一个命令用{}表示

sed -e '/^north/h' -e '$G' datafile
#1)匹配模式后放到暂存缓冲区， 
#2)匹配最后一行后，取出holding buffer内容，追加匹配行(本例即最后一行)
```

## shell

orders for looking cmd:
- alias
- shell keyword
- function
- inside cmd
- path

> pipline
> who | wc

> redirect
> who > file


cmd    |        comment          |
------ | ----------------------- |
ps     | current shell thread    |
ps aux | show all thread         |
pstree | show thread tree        |
id     | current user            |
env    | show shell env value    |
set    | show or set shell value |
tail -f| follow                  |
ssh    | ssh root@some.example.com| 
top    | info about processes |


> scripts

```
#!/bin/bash     #first line
* ? [ ]         #用于文件名通配符
< > 2> >> |     #用于IO重定向和管道

echo how are you \<?\>
echo "how are you <?>"  #通配符必须用反斜杠或引号输出

var=value       #不能有空格
declare var=value;  #declare内置函数定义局部变量

export VAR=value    #export内置函数定义全局变量
            #全局变量当脚本执行结束，退出子进程，依然存在

echo $var       #$提取变量

read name1 name2    #读取用户输入

#命令行参数
$scriptname arg1 arg2 arg3 ...
#脚本中
echo $1 $2 $3...    #命令行参数
echo $*         #所有参数
echo $#         #参数的个数

declare -a array_name=(word1 word2 word3...)        #定义数组
declare -a fruit=(apples pears plums)
echo ${fruit[0]}                    #读取数组

var=`cmd`       #使用命令输出
var=$(cmd)      #
echo "Today is `date`"  #
echo "Today is $(date)" #

#if...else
if command          #命令
if [[expression]]       #表达式求真
if ((numeric expression))   #算术式求真
then
    block of statements
else
    block of statements
fi

case $color in
blue)
    echo blue
    ;;
green)
    echo green
    ;;
*)
    echo donot know
    ;;
esac


$?      #最后一个命令的退出状态, 0为正常退出
```



# code

#### dir

```
#include <sys/types.h>
#include <sys/stat.h>

int stat(const char* pathname, struct stat* buf);
int fstat(int filedes, struct stat* buf);
int lstat(const char* pathname, struct stat* buf);


struct stat {
	mode_t 	st_mode;	//file type & mode
	ino_t	st_ino;		//inode number
	dev_t	st_dev;		//device number
	dev_t	st_rdev;	//device number for special files
	nlink_t	st_nlink;	//number of links
	uid_t	st_uid;		//user id for owner
	gid_t	st_gid;		//group id for owner
	off_t	st_size;	//size in bytes, for regular files
	time_t	st_atimve;	//time of last access
	time_t 	st_mtime;	//time of last modification
	time_t	st_ctime;	//time of last file status change
	long	st_blksize;	//best IO block size
	long	st_blocks;	//number of 512-byte blocks allocated
}

------------------------
文件类型				|
------------------------|
<sys/stat.h>			|
------------------------|
S_ISREG(st_mode)		|
S_ISDIR(st_mode)		|
S_ISCHR(st_mode)		|
S_ISBLK(st_mode)		|
S_ISFIFO(st_mode)		|
S_ISLNK(st_mode)		|
S_ISSOCK(st_mode)		|	
------------------------

--------------------------------	
用户ID							|
-------------------------------	|
实际uid		实际上是谁			|
实际gid							|
-------------------------------	|
有效uid		用于文件许可权检查	|
有效gid							|
添加gid							|
-------------------------------	|
保存设置uid	由exec函数保存		|
保存设置gid						|
--------------------------------




======================================================================
#include <unistd.h>
int access(const char* pathname, int mode);	//成功返回0
	mode
	R_OK	//读许可权
	W_OK	//写许可权
	X_OK	//执行许可权
	F_OK	//文件是否存在





======================================================================
#include <sys/types.h>
#include <sys/stat.h>

mode_t umask(mode_t cmask);	//返回旧屏蔽字，将cmask中指定的权限从后续的文件操作中去掉
	cmask
	S_IRUSR		//用户-读
	S_IWUSR		//用户-写
	S_IXUSR		//用户-执行
	S_IRGRP		//组-读
	S_IWGRP		//组-写
	S_IXGRP		//组-执行
	S_IROTH		//其他-读
	S_IWOTH		//其他-写
	S_IXOTH		//其他-执行


======================================================================
#include <sys/types.h>
#include <sys/stat.h>

int chmode(const char* pathname, mode_t mode);
int fchmod(int filedes, mode_t mode);
	mode
	S_ISUID
	S_ISGID
	S_ISVTX
	S_IRWXU	= S_IRUSR S_IWUSR S_IXUSR
	S_IRWXG = S_IRGRP S_IWGRP S_IXGRP
	S_IRWXO = S_IROTH S_IWOTH S_IXOTH


======================================================================
#include <sys/types.h>
#include <unistd.h>

int chown(const char* pathname, uid_t owner, gid_t group);
int fchown(int filedes, uid_t owner, gid_t group);
int lchown(const char* pathname, uid_t owner, gid_t group);

文件截断
======================================================================
#include <sys/types.h>
#include <unistd.h>

int truncate(const char* pathname, off_t length);
int ftruncate(int filedes, off_t length);




======================================================================
#inlcude <unistd.h>
int link(const char* existingpath, const char* newpath);

#include <unistd.h>
int unlink(const char* pathname);		//删除一个现存的目录项

#include <stdio.h>
int remove(const char* pathname);		//对文件与unlink函数相同，对于目录与rmdir函数相同

#include <stdio.h>
int rename(const char* oldname, const char* newname);



#include <unistd.h>
int symlink(const char* acutualpath, const char* sympath);	//创建链接
int readlink(const char* pathname, char buf, int bufsize);	//组合了open，read，close



#include <sys/types.h>
#include <utime.h>
int utime(const char* pathname, const struct utimebuf times);	//文件的存取/修改时间
```

#### IO

```
===============================================
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open(const char* pathname, int oflag, .../*, mode_t mods */);	//返回文件描述符
	oflag
	O_RDONLY	0	只读
	O_WRONLY	1	只写
	O_RDWR		2	读写
	O_APPEND		写到文件尾
	O_CREAT			若不存在则创建，需要创建mods
	O_EXCL			同时指定O_CREAT， 文件存在则出错，文件不存在则创建
	O_TRUNC			若文件存在，且只读或只写打开，则文件长度截短为0
	O_NOCTTY		若打开终端设备，则不将此设备分配为此进程的控制终端
	O_NONBLOCK		若打开FIFO、块文件、字符文件，为此文件的本次打开操作和后续的IO操作设置非阻塞方式
	O_SYNC			每次write都等到物理IO完成才返回，同步


===============================================
#include <sys/types.h>
#include <sys/stat.h>
#icnlude <fcntl.h>

int creat(const char* pathname, mode_t mode);		//返回文件描述符
open(pathname, O_WRONLY|O_CREAT|O_TRUNC, mode);		//等价于


===============================================
#include <unistd.h>
int close(int filedes);		//成功:0, 出错:-1

===============================================
#include <sys/types.h>
#include <unistd.h>

off_t lseek(int filedes, off_t offset, int whence);		//如果文件为管道文件或FIFO，返回-1
//whence
//SEEK_SET	设置文件当前位置为 文件开始+offset，offset取正值
//SEEK_CUR	设置文件当前位置为 当前位置+offset，offset取正负值
//SEEK_END	设置文件当前位置为 文件长度+offset，offset取正负值

off_t currpos = lseek(fd, 0, SEEK_CUR);		//获取文件当前位置
//如果文件为管道文件或FIFO，返回-1
//lseek不引起文件IO
//文件位移可以大于文件长度，对该文件的下一次写将延长文件，并留下空洞


===============================================
#include <unistd.h>
ssize_t read(int filedes, void *buff,  size_t nbytes);		//返回读到的字节数，0为文件尾

//从终端设备读时，一次最多读一行
//从网络读时，最多读取缓冲中的字符数

#include <unistd.h>
ssize_t write(int filedes, const void* buff, size_t nbytes);	//返回已写的字节数


===============================================
#include <unistd.h>
int dup(int filedes);	//返回当前最小的可用文件描述符
			//等效于fcntl(filedes, F_DUPFD, 0);
int dup2(int filedes, int filedes2);		//已filedes2指定新描述符的数值, 如果filedes2已经打开，先将其关闭
			//等效于close(filedes2); fcntl(filedes, F_DUPFD, filedes2);



#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>

int fcntl(int filedes, int cmd, ... /* int arg */);	
	cmd
	F_DUPFD		//复制现存的描述符， 		返回新文件描述符
	F_GETFD		//获得/设置文件描述符标志	返回文件描述符标志
	F_SETFD		
	F_GETFL		//获得/设置文件状态标志		
	F_SETFL		
	F_GETOWN	//获得/设置异步I/O有权
	F_SETOWN
	F_GETLK		//获得/设置记录锁
	F_SETLK
	F_SETLKW
	

	F_GETFL/F_SETFL
	文件状态标志位
	O_RDONLY	//只读打开
	O_WRONLY	//只写打开
	O_RDWR		//读写打开,	这三个的掩码为O_ACCMODE
	O_APPEND	//写时添加至文件尾
	O_NONBLOCK	//非阻塞方式
	O_YNC		//等待写完成
	O_ASYNC		//异步IO



======================================================================================
#include <unistd.h>
#include <sys/ioctl.h>

int ioctl(int filedes, int request, ...);	




======================================================================================
```


#### signal

```
int sigemptyset(sigset_t *set); //创建set并且情况信号集
int sigfillset(sigset_t *set); //创建set并使set包含所有linux的信号
int addset(sigset_t *set,int signo);      //给set信号集增加一个signo信号
int sigdelset(sigset_t*set,int signo); //将set信号集中的signo定义的信号剔除

以上四个函数成功调用返回0,失败返回1

int sigismember(const sigset_t *set,int signo); //判断set信号集中是否已经包含signo所指向的信号,真返回1,假返回0
int sigprocmask(int how,const sigset_t *set,sigset_t *oset);    //设置信号集的屏蔽位,如果oset不为NULL,则oset返回当前修改之前的屏蔽字
how的参数定义
SIG_BLOCK : 屏蔽set所包含的所有信号
SIG_UNBLOCK : 解除set所包含的所有信号
SIG_SETMASK : 直接设置屏蔽信号所指向的值给set信号集

int sigaction(int signo,const struct sigction *act,struct sigaction *oact);
sigaction函数的功能是检测或者修改signo信号关联的处理动作
signo是要检测或者修改具体动作的信号编号数,若act非NULL,则修改它的动作,如果oact非NULL,则返回该信号的原先动作
struct sigaction{
void (*sa_handler)(int signo); //用户自定义处理函数,或者SIG_DFL或者 SIG_IGN
sigset_t sa_mask;       //信号集,用来指导在信号处理指向过程中哪些信号要被阻塞
int sa_flags;   //信号选项,包括是否则色,是否忽略SIGSTOP,SIGSTP,SIGTTIN,SIGTTOU信号,是否自定义信号只执行一次等等
void (*as_restore);       
}

int sigpending(sigset_t *set); //用于检测set信号集中是否为未决的信号,比如在信号集阻塞时的信号


sa_restorer已过时，POSIX不支持它，不应再使用。

当你的信号需要接收附加信息的时候，你必须给sa_sigaction赋信号处理函数指针，同时还要给sa_flags赋SA_SIGINFO, 如下：

              sigemptyset(&sig_act.sa_mask);
              sig_act.sa_sigaction=sig_handler_with_arg;
              sig_act.sa_flags=SA_SIGINFO;
如果你的应用程序只需要接收信号，而不需要接收额外信息，那你需要的设置的是sa_handler,而不是sa_sigaction，如下：
              sigemptyset(&sig_act.sa_mask);
              sig_act.sa_handler=sig_handler;
              sig_act.sa_flags=0;


新版本
信号发送函数sigqueue()及信号安装函数sigaction()


信号值位于SIGRTMIN和SIGRTMAX之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。
这些信号支持排队，不会丢失。 

信号阻塞：当信号发生而无法处理的时候，不要忽略该信号，在进程准备好时再通知它
信号产生到在进程上标记标志之间，信号未决(pending)

三个函数改变信号屏蔽字
sigpending将制定的哦信号设置为阻塞和pending
sigprocmask查询和设置当前进程的信号屏蔽字
sigsuspend在原子操作中实现恢复信号屏蔽字,并且使进程睡眠
```


#### temp

```
//错误处理
===========================================================
//<errno.h>中定义了变量errno

#include <string.h>
char* strerrno(int errno);		//指向消息字符串的指针

#include <stdio.h>
void perror(const char* msg)	//输出以msg开头的错误信息，错误信息定义来自errno



目录的读权限：对目录进行搜索的能力
目录的写权限：在目录中创建和删除文件的能力
目录的执行权限：打开或访问目录中包含的文件或子目录时搜索目录的能力

粘着位sticky bit:t
如果文件设置了粘着位，那么只有文件的数组或root才可以删除该文件
```






# misc

#### init

> **redhat启动脚本顺序**
>
> - 加载内核
> - 执行init程序
> -/etc/rc.d/rc.sysinit
	- #调入keymap及系统字体
	- #启动swapping
	- #设置主机名
	- #设置NIS域名
	- #fsck 并mount文件系统
	- #打开quota
	- #装载声卡模块
	- #设置系统时钟
> - /etc/rc.d/rc $RUNLEVEL  #/etc/inittab中设定$RUNLEVEL
	- #执行相应等级目录下的脚本/etc/rc.d/rc3.d/Sxxx
> - /etc/rc.d/rc.local
> - /sbin/mingetty      #等待用户登录

#### rpm 
```
finger @kernl.org           //获得最新的代码列表


Redhat Package Manager 
rpm -e --nodeps             //强制卸载
rpm -i src.rpm              //安装软件源代码包
rpmbuild -bb H.src          //做rpm
rpm -ivh                    //安装rpm
rpm -Uivh                   //升级



apt-get update
apt-get install 
apt-get remove
```

